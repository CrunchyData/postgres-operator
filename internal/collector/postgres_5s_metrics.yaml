# This list of queries configures an OTel SQL Query Receiver to read pgMonitor
# metrics from Postgres.
#
# https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/-/receiver/sqlqueryreceiver#metrics-queries
# https://github.com/CrunchyData/pgmonitor/blob/development/sql_exporter/common/crunchy_global_collector.yml
#
  # TODO ccp_pg_stat_activity can be removed/replaced once an equivalent metric is added to pgMonitor
  - sql: >
      SELECT
          pg_database.datname,
          tmp.state,
          COALESCE(tmp2.usename, '') as usename,
          COALESCE(tmp2.application_name, '') as application_name,
          COALESCE(count,0) as count,
          COALESCE(max_tx_duration,0) as max_tx_duration
      FROM
          (
            VALUES ('active'),
                   ('idle'),
                   ('idle in transaction'),
                   ('idle in transaction (aborted)'),
                   ('fastpath function call'),
                   ('disabled')
          ) AS tmp(state) CROSS JOIN pg_database
      LEFT JOIN
      (
          SELECT
              datname,
              state,
              usename,
              application_name,
              count(*) AS count,
              MAX(EXTRACT(EPOCH FROM now() - xact_start))::float AS max_tx_duration
          FROM pg_stat_activity GROUP BY datname,state,usename,application_name) AS tmp2
          ON tmp.state = tmp2.state AND pg_database.datname = tmp2.datname;
    metrics:
      - metric_name: ccp_pg_stat_activity_count
        value_column: count
        description: number of connections in this state
        attribute_columns: ["application_name", "datname", "state", "usename"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT
        COALESCE(EXTRACT(epoch from (CURRENT_TIMESTAMP - last_archived_time)), 0) AS seconds_since_last_archive,
        archived_count,
        failed_count,
        CASE
          WHEN EXTRACT(epoch from (last_failed_time - last_archived_time)) IS NULL THEN 0
          WHEN EXTRACT(epoch from (last_failed_time - last_archived_time)) < 0 THEN 0
          ELSE EXTRACT(epoch from (last_failed_time - last_archived_time))
        END AS seconds_since_last_fail
      FROM pg_catalog.pg_stat_archiver;
    metrics:
      - metric_name: ccp_archive_command_status_seconds_since_last_archive
        value_column: seconds_since_last_archive
        value_type: double
        description: Seconds since the last successful archive operation
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_archive_command_status_archived_count
        value_column: archived_count
        description: Number of WAL files that have been successfully archived
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_archive_command_status_failed_count
        value_column: failed_count
        description: Number of failed attempts for archiving WAL files
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_archive_command_status_seconds_since_last_fail 
        value_column: seconds_since_last_fail
        description: Seconds since the last recorded failure of the archive_command
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT ((total - idle) - idle_in_txn) as active
          , total
          , idle
          , idle_in_txn
          , (SELECT COALESCE(EXTRACT(epoch FROM (MAX(clock_timestamp() - state_change))),0) FROM pg_catalog.pg_stat_activity WHERE state = 'idle in transaction') AS max_idle_in_txn_time
          , (SELECT COALESCE(EXTRACT(epoch FROM (MAX(clock_timestamp() - query_start))),0) FROM pg_catalog.pg_stat_activity WHERE backend_type = 'client backend' AND state <> 'idle' ) AS max_query_time
          , (SELECT COALESCE(EXTRACT(epoch FROM (MAX(clock_timestamp() - query_start))),0) FROM pg_catalog.pg_stat_activity WHERE backend_type = 'client backend' AND wait_event_type = 'Lock' ) AS max_blocked_query_time
          , max_connections
          FROM (
                  SELECT COUNT(*) as total
                          , COALESCE(SUM(CASE WHEN state = 'idle' THEN 1 ELSE 0 END),0) AS idle
                          , COALESCE(SUM(CASE WHEN state = 'idle in transaction' THEN 1 ELSE 0 END),0) AS idle_in_txn FROM pg_catalog.pg_stat_activity) x
          JOIN (SELECT setting::float AS max_connections FROM pg_settings WHERE name = 'max_connections') xx ON (true);
    metrics:
      - metric_name: ccp_connection_stats_active
        value_column: active
        description: Total non-idle connections
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_idle
        value_column: idle
        description: Total idle connections
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_idle_in_txn
        value_column: idle_in_txn
        description: Total idle in transaction connections 
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_max_blocked_query_time 
        value_column: max_blocked_query_time
        value_type: double
        description: Value of max_connections for the monitored database
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_max_connections
        value_column: max_connections
        description: Value of max_connections for the monitored database
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_max_idle_in_txn_time
        value_column: max_idle_in_txn_time
        value_type: double
        description: Length of time in seconds of the longest idle in transaction session
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_max_query_time
        value_column: max_query_time
        value_type: double
        description: Length of time in seconds of the longest running query
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_connection_stats_total
        value_column: total
        description: Total idle and non-idle connections
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT datname AS dbname
      , checksum_failures AS count
      , coalesce(extract(epoch from (clock_timestamp() - checksum_last_failure)), 0) AS time_since_last_failure_seconds
      FROM pg_catalog.pg_stat_database
      WHERE pg_stat_database.datname IS NOT NULL;
    metrics:
      - metric_name: ccp_data_checksum_failure_count
        value_column: count
        attribute_columns: ["dbname"]
        description: Total number of checksum failures on this database
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_data_checksum_failure_time_since_last_failure_seconds
        value_column: time_since_last_failure_seconds
        value_type: double
        attribute_columns: ["dbname"]
        description: Time interval in seconds since the last checksum failure was encountered
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT pg_database.datname as dbname
      , tmp.mode
      , COALESCE(count,0) as count
      FROM
      (
        VALUES ('accesssharelock'),
               ('rowsharelock'),
               ('rowexclusivelock'),
               ('shareupdateexclusivelock'),
               ('sharelock'),
               ('sharerowexclusivelock'),
               ('exclusivelock'),
               ('accessexclusivelock')
      ) AS tmp(mode) CROSS JOIN pg_catalog.pg_database
      LEFT JOIN
          (SELECT database, lower(mode) AS mode,count(*) AS count
          FROM pg_catalog.pg_locks WHERE database IS NOT NULL
          GROUP BY database, lower(mode)
      ) AS tmp2
      ON tmp.mode=tmp2.mode and pg_database.oid = tmp2.database;
    metrics:
      - metric_name: ccp_locks_count
        value_column: count
        attribute_columns: ["dbname", "mode"]
        description: Number of locks per mode type
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT monitor.kdapi_scalar_bigint('cpu_request') AS request
      , monitor.kdapi_scalar_bigint('cpu_limit') AS limit;
    metrics:
      - metric_name: ccp_nodemx_cpu_limit
        value_column: limit
        description: CPU limit value in milli cores
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpu_request 
        value_column: request
        description: CPU request value in milli cores
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT CASE WHEN monitor.cgroup_mode() = 'legacy'
        THEN monitor.cgroup_scalar_bigint('cpuacct.usage')
        ELSE (SELECT val FROM monitor.cgroup_setof_kv('cpu.stat') where key = 'usage_usec') * 1000
        END AS usage,
        extract(epoch from clock_timestamp()) AS usage_ts;
    metrics:
      - metric_name: ccp_nodemx_cpuacct_usage
        value_column: usage
        value_type: double
        description: CPU usage in nanoseconds 
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpuacct_usage_ts
        value_column: usage_ts
        value_type: double
        description: CPU usage snapshot timestamp
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT
        CASE
        WHEN monitor.cgroup_mode() = 'legacy' THEN
          monitor.cgroup_scalar_bigint('cpu.cfs_period_us')
        ELSE
          (monitor.cgroup_array_bigint('cpu.max'))[2]
        END AS period_us,
        CASE
        WHEN monitor.cgroup_mode() = 'legacy' THEN
          GREATEST(monitor.cgroup_scalar_bigint('cpu.cfs_quota_us'), 0)
        ELSE
          GREATEST((monitor.cgroup_array_bigint('cpu.max'))[1], 0)
        END AS quota_us;
    metrics:
      - metric_name: ccp_nodemx_cpucfs_period_us
        value_column: period_us
        description: The total available run-time within a period (in microseconds)
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpucfs_quota_us
        value_column: quota_us
        value_type: double
        description: The length of a period (in microseconds)
        static_attributes:
          server: "localhost:5432"

  # NOTE: cgroup v2 has throttled_usec, vs. throttled_time.
  - sql: >
      WITH d(key, val) AS
      (select key, val from monitor.cgroup_setof_kv('cpu.stat'))
      SELECT
       (SELECT val FROM d WHERE key='nr_periods') AS nr_periods,
       (SELECT val FROM d WHERE key='nr_throttled') AS nr_throttled,
       (SELECT val FROM d WHERE key='throttled_usec') AS throttled_time,
       extract(epoch from clock_timestamp()) as snap_ts;
    metrics:
      - metric_name: ccp_nodemx_cpustat_nr_periods
        value_column: nr_periods
        value_type: double
        description: Number of periods that any thread was runnable
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpustat_nr_throttled
        value_column: nr_throttled
        description: Number of runnable periods in which the application used its entire quota and was throttled
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpustat_snap_ts
        value_column: snap_ts
        value_type: double
        description: CPU stat snapshot timestamp
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_cpustat_throttled_time
        value_column: throttled_time
        value_type: double # TODO: Is this right?
        description: Sum total amount of time individual threads within the monitor.cgroup were throttled
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT mount_point,fs_type,total_bytes,available_bytes,total_file_nodes,free_file_nodes
                FROM monitor.proc_mountinfo() m
                JOIN monitor.fsinfo(m.mount_point) f USING (major_number, minor_number)
                WHERE m.mount_point IN ('/pgdata', '/pgwal') OR
                      m.mount_point like '/tablespaces/%';
    metrics:
      - metric_name: ccp_nodemx_data_disk_available_bytes 
        value_column: available_bytes
        value_type: double
        description: Available size in bytes
        attribute_columns: ["fs_type", "mount_point"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_data_disk_free_file_nodes
        value_column: free_file_nodes
        description: Available file nodes
        attribute_columns: ["fs_type", "mount_point"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_data_disk_total_bytes
        value_column: total_bytes
        description: Size in bytes
        attribute_columns: ["fs_type", "mount_point"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_data_disk_total_file_nodes
        value_column: total_file_nodes
        description: Total file nodes
        attribute_columns: ["fs_type", "mount_point"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT mount_point,sectors_read,sectors_written
                FROM monitor.proc_mountinfo() m
                JOIN monitor.proc_diskstats() d USING (major_number, minor_number)
                WHERE m.mount_point IN ('/pgdata', '/pgwal') OR
                      m.mount_point like '/tablespaces/%';
    metrics:
      - metric_name: ccp_nodemx_disk_activity_sectors_read
        value_column: sectors_read
        description: Total sectors read
        attribute_columns: ["mount_point"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_disk_activity_sectors_written
        value_column: sectors_written
        description: Total sectors written
        attribute_columns: ["mount_point"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH d(key, val) as (SELECT key, val FROM monitor.cgroup_setof_kv('memory.stat'))
      SELECT
        monitor.kdapi_scalar_bigint('mem_request') AS request,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy' THEN
              (CASE WHEN monitor.cgroup_scalar_bigint('memory.limit_in_bytes') = 9223372036854771712 THEN 0 ELSE monitor.cgroup_scalar_bigint('memory.limit_in_bytes') END)
          ELSE
              (CASE WHEN monitor.cgroup_scalar_bigint('memory.max') = 9223372036854775807 THEN 0 ELSE monitor.cgroup_scalar_bigint('memory.max') END)
        END AS limit,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN (SELECT val FROM d WHERE key='cache')
          ELSE 0
        END as cache,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN (SELECT val FROM d WHERE key='rss')
          ELSE 0
        END as RSS,
        (SELECT val FROM d WHERE key='shmem') as shmem,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN (SELECT val FROM d WHERE key='mapped_file')
          ELSE 0
        END as mapped_file,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN (SELECT val FROM d WHERE key='dirty')
          ELSE (SELECT val FROM d WHERE key='file_dirty')
        END as dirty,
        (SELECT val FROM d WHERE key='active_anon') as active_anon,
        (SELECT val FROM d WHERE key='inactive_anon') as inactive_anon,
        (SELECT val FROM d WHERE key='active_file') as active_file,
        (SELECT val FROM d WHERE key='inactive_file') as inactive_file,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN monitor.cgroup_scalar_bigint('memory.usage_in_bytes')
          ELSE monitor.cgroup_scalar_bigint('memory.current')
        END as usage_in_bytes,
        CASE
          WHEN monitor.cgroup_mode() = 'legacy'
          THEN monitor.cgroup_scalar_bigint('memory.kmem.usage_in_bytes')
          ELSE 0
        END as kmem_usage_in_byte;
    metrics:
      - metric_name: ccp_nodemx_mem_active_anon
        value_column: active_anon
        value_type: double
        description: Total bytes of anonymous and swap cache memory on active LRU list 
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_active_file 
        value_column: active_file
        value_type: double
        description: Total bytes of file-backed memory on active LRU list
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_cache  
        value_column: cache
        value_type: double
        description: Total bytes of page cache memory 
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_dirty
        value_column: dirty
        description: Total bytes that are waiting to get written back to the disk
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_inactive_anon 
        value_column: inactive_anon
        value_type: double
        description: Total bytes of anonymous and swap cache memory on inactive LRU list
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_inactive_file 
        value_column: inactive_file
        value_type: double
        description: Total bytes of file-backed memory on inactive LRU list
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_kmem_usage_in_byte 
        value_column: kmem_usage_in_byte
        description: Unknown metric from ccp_nodemx_mem
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_limit 
        value_column: limit
        description: Memory limit value in bytes
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_mapped_file 
        value_column: mapped_file
        description: Total bytes of mapped file (includes tmpfs/shmem)
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_request 
        value_column: request
        description: Memory request value in bytes
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_rss 
        value_column: rss
        value_type: double
        description: Total bytes of anonymous and swap cache memory
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_shmem 
        value_column: shmem
        value_type: double
        description: Total bytes of shared memory
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_mem_usage_in_bytes 
        value_column: usage_in_bytes
        description: Total usage in bytes
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT interface
        ,tx_bytes
        ,tx_packets
        ,rx_bytes
        ,rx_packets from monitor.proc_network_stats();
    metrics:
      - metric_name: ccp_nodemx_network_rx_bytes
        value_column: rx_bytes
        description: Number of bytes received
        attribute_columns: ["interface"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_network_rx_packets 
        value_column: rx_packets
        description: Number of packets received
        attribute_columns: ["interface"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_network_tx_bytes 
        value_column: tx_bytes
        description: Number of bytes transmitted
        attribute_columns: ["interface"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_nodemx_network_tx_packets 
        value_column: tx_packets
        description: Number of packets transmitted
        attribute_columns: ["interface"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT monitor.cgroup_process_count() as count;
    metrics:
      - metric_name: ccp_nodemx_process_count
        value_column: count
        description: Total number of database processes
        static_attributes:
          server: "localhost:5432"

  # Setting pg_stat_statements_reset_info to -1 means update as often as possible.
  - sql: >
      SELECT monitor.pg_stat_statements_reset_info(-1) as time;
    metrics:
      - metric_name: ccp_pg_stat_statements_reset_time
        value_column: time
        description: Epoch time when stats were reset
        static_attributes:
          server: "localhost:5432"


  # This query against pg_stat_statements is compatible with PG 13 and later.
  # https://github.com/CrunchyData/pgmonitor-extension/blob/main/sql/functions/functions.sql
  # TODO: Double-check the sorting and the attribute values on the below.
  - sql: >
      WITH monitor AS (
        SELECT
          pg_get_userbyid(s.userid) AS role
          , d.datname AS dbname
          , s.queryid AS queryid
          , btrim(replace(left(s.query, 40), '\n', '')) AS query
          , s.calls
          , s.total_exec_time AS total_exec_time
          , s.max_exec_time AS max_exec_time
          , s.mean_exec_time AS mean_exec_time
          , s.rows
          , s.wal_records AS records
          , s.wal_fpi AS fpi
          , s.wal_bytes AS bytes
        FROM public.pg_stat_statements s
        JOIN pg_catalog.pg_database d ON d.oid = s.dbid
      )
      SELECT role
        , dbname
        , queryid
        , query
        , max(monitor.mean_exec_time) AS top_mean_exec_time_ms
      FROM monitor
      GROUP BY 1,2,3,4
      ORDER BY 5 DESC
      LIMIT 20;
    metrics:
      - metric_name: ccp_pg_stat_statements_top_mean_exec_time_ms 
        value_column: top_mean_exec_time_ms
        value_type: double
        description: Average query runtime in milliseconds
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH monitor AS (
        SELECT
          pg_get_userbyid(s.userid) AS role
          , d.datname AS dbname
          , s.calls
          , s.total_exec_time
          , s.mean_exec_time
          , s.rows
        FROM public.pg_stat_statements s
        JOIN pg_catalog.pg_database d ON d.oid = s.dbid
      )
      SELECT role
        , dbname
        , sum(calls) AS calls_count
        , sum(total_exec_time) AS exec_time_ms
        , avg(mean_exec_time) AS mean_exec_time_ms
        , sum(rows) AS row_count
      FROM monitor
      GROUP BY 1,2;
    metrics:
      - metric_name: ccp_pg_stat_statements_total_calls_count 
        value_column: calls_count
        value_type: double
        description: Total number of queries run per user/database
        attribute_columns: ["dbname", "role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_pg_stat_statements_total_exec_time_ms 
        value_column: exec_time_ms
        value_type: double
        description: Total runtime of all queries per user/database
        attribute_columns: ["dbname", "role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_pg_stat_statements_total_mean_exec_time_ms
        value_column: mean_exec_time_ms
        value_type: double
        description: Total runtime of all queries per user/database
        attribute_columns: ["dbname", "role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_pg_stat_statements_total_row_count 
        value_column: row_count
        value_type: double
        description: Total rows returned from all queries per user/database
        attribute_columns: ["dbname", "role"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT current_setting('server_version_num')::int AS current;
    metrics:
      - metric_name: ccp_postgresql_version_current
        value_column: current
        description: The current version of PostgreSQL that this exporter is running on as a 6 digit integer (######).
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT extract(epoch from (clock_timestamp() - pg_postmaster_start_time() )) AS seconds;
    metrics:
      - metric_name: ccp_postmaster_uptime_seconds
        value_column: seconds
        value_type: double
        description: Time interval in seconds since PostgreSQL database was last restarted.
        static_attributes:
          server: "localhost:5432"

  # get_replication_lag is created in metrics_setup.sql
  - sql: >
      SELECT * FROM get_replication_lag();
    metrics:
      - metric_name: ccp_replication_lag_size_bytes
        value_column: bytes
        value_type: double
        description: Replication lag in bytes.
        attribute_columns: ['replica']
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT
         COALESCE(
            CASE
               WHEN (pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn()) OR (pg_is_in_recovery() = false) THEN 0
               ELSE EXTRACT (EPOCH FROM clock_timestamp() - pg_last_xact_replay_timestamp())::INTEGER
            END,
            0
         ) AS replay_time,
         COALESCE(
            CASE
               WHEN pg_is_in_recovery() = false THEN 0
               ELSE EXTRACT (EPOCH FROM clock_timestamp() - pg_last_xact_replay_timestamp())::INTEGER
            END,
            0
         ) AS received_time,
         CASE
            WHEN pg_is_in_recovery() = true THEN 'replica'
            ELSE 'primary'
         END AS role,
         CASE
            WHEN pg_is_in_recovery() = true THEN 1
            ELSE 2
         END AS status;
    metrics:
      - metric_name: ccp_is_in_recovery_status
        value_column: status
        value_type: double
        description: Return value of 1 means database is in recovery. Otherwise 2 it is a primary
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_replication_lag_received_time 
        value_column: received_time
        value_type: double
        description: |
          Length of time since the last WAL file was received and replayed on replica.
          Always increases, possibly causing false positives if the primary stops writing.
          Monitors for replicas that stop receiving WAL all together.
        attribute_columns: ["role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_replication_lag_replay_time 
        value_column: replay_time
        value_type: double
        description: |
          Length of time since the last transaction was replayed on replica.
          Returns zero if last WAL received equals last WAL replayed. Avoids
          false positives when primary stops writing. Monitors for replicas that
          cannot keep up with primary WAL generation.
        attribute_columns: ["role"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT count(*) AS count FROM pg_catalog.pg_settings WHERE pending_restart = true;
    metrics:
      - metric_name: ccp_settings_pending_restart_count 
        value_column: count
        description: Number of settings from pg_settings catalog in a pending_restart state
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT
          buffers_clean
          , maxwritten_clean
          , buffers_alloc
      FROM pg_catalog.pg_stat_bgwriter;
    metrics:
      - metric_name: ccp_stat_bgwriter_buffers_alloc 
        value_column: buffers_alloc
        description: Number of buffers allocated
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_bgwriter_buffers_clean  
        value_column: buffers_clean
        data_type: sum
        description: Number of buffers written by the background writer
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_bgwriter_maxwritten_clean 
        value_column: maxwritten_clean
        description: Number of times the background writer stopped a cleaning scan because it had written too many buffers
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH max_age AS (
          SELECT 2000000000 as max_old_xid
          , setting AS autovacuum_freeze_max_age
          FROM pg_catalog.pg_settings
          WHERE name = 'autovacuum_freeze_max_age')
      , per_database_stats AS (
          SELECT datname
          , m.max_old_xid::int
          , m.autovacuum_freeze_max_age::int
          , age(d.datfrozenxid) AS oldest_current_xid
          FROM pg_catalog.pg_database d
          JOIN max_age m ON (true)
          WHERE d.datallowconn)
      SELECT max(oldest_current_xid) AS oldest_current_xid
      , max(ROUND(100*(oldest_current_xid/max_old_xid::float))) AS percent_towards_wraparound
      , max(ROUND(100*(oldest_current_xid/autovacuum_freeze_max_age::float))) AS percent_towards_emergency_autovac
      FROM per_database_stats;
    metrics:
      - metric_name: ccp_transaction_wraparound_oldest_current_xid 
        value_column: oldest_current_xid
        description: Oldest current transaction ID in cluster
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_transaction_wraparound_percent_towards_emergency_autovac 
        value_column: percent_towards_emergency_autovac
        description: Percentage towards emergency autovacuum process starting
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_transaction_wraparound_percent_towards_wraparound
        value_column: percent_towards_wraparound
        description: Percentage towards transaction ID wraparound
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT last_5_min_size_bytes,
        (SELECT COALESCE(sum(size),0) FROM pg_catalog.pg_ls_waldir()) AS total_size_bytes
        FROM (SELECT COALESCE(sum(size),0) AS last_5_min_size_bytes FROM pg_catalog.pg_ls_waldir() WHERE modification > CURRENT_TIMESTAMP - '5 minutes'::interval) x;
    metrics:
      - metric_name: ccp_wal_activity_total_size_bytes 
        value_column: total_size_bytes
        description: Current size in bytes of the WAL directory
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH monitor AS (
        SELECT
          pg_get_userbyid(s.userid) AS role
          , d.datname AS dbname
          , s.queryid AS queryid
          , btrim(replace(left(s.query, 40), '\n', '')) AS query
          , s.calls
          , s.total_exec_time AS total_exec_time
          , s.max_exec_time AS max_exec_time_ms
          , s.rows
          , s.wal_records AS records
          , s.wal_fpi AS fpi
          , s.wal_bytes AS bytes
        FROM public.pg_stat_statements s
        JOIN pg_catalog.pg_database d ON d.oid = s.dbid
      )
      SELECT role
        , dbname
        , queryid
        , query
        , max_exec_time_ms
        , records
      FROM monitor
      ORDER BY 5 DESC
      LIMIT 20;
    metrics:
      - metric_name: ccp_pg_stat_statements_top_max_exec_time_ms
        value_column: max_exec_time_ms
        value_type: double
        description: Epoch time when stats were reset
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH monitor AS (
        SELECT
          pg_get_userbyid(s.userid) AS role
          , d.datname AS dbname
          , s.queryid AS queryid
          , btrim(replace(left(s.query, 40), '\n', '')) AS query
          , s.calls
          , s.total_exec_time AS total_exec_time_ms
          , s.rows
          , s.wal_records AS records
          , s.wal_fpi AS fpi
          , s.wal_bytes AS bytes
        FROM public.pg_stat_statements s
        JOIN pg_catalog.pg_database d ON d.oid = s.dbid
      )
      SELECT role
        , dbname
        , queryid
        , query
        , total_exec_time_ms
        , records
      FROM monitor
      ORDER BY 5 DESC
      LIMIT 20;
    metrics:
      - metric_name: ccp_pg_stat_statements_top_total_exec_time_ms 
        value_column: total_exec_time_ms
        value_type: double
        description: Total time spent in the statement in milliseconds
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      WITH monitor AS (
        SELECT
          pg_get_userbyid(s.userid) AS role
          , d.datname AS dbname
          , s.queryid AS queryid
          , btrim(replace(left(s.query, 40), '\n', '')) AS query
          , s.calls
          , s.total_exec_time AS total_exec_time
          , s.max_exec_time AS max_exec_time
          , s.mean_exec_time AS mean_exec_time
          , s.rows
          , s.wal_records AS records
          , s.wal_fpi AS fpi
          , s.wal_bytes AS bytes
        FROM public.pg_stat_statements s
        JOIN pg_catalog.pg_database d ON d.oid = s.dbid
      )
      SELECT role
        , dbname
        , query
        , queryid
        , records
        , fpi
        , bytes
      FROM monitor
      ORDER BY bytes DESC
      LIMIT 20;
    metrics:
      - metric_name: ccp_pg_stat_statements_top_wal_bytes
        value_column: bytes
        value_type: double
        description: Total amount of WAL generated by the statement in bytes
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_pg_stat_statements_top_wal_fpi
        value_column: fpi
        value_type: double
        description: Total number of WAL full page images generated by the statement
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_pg_stat_statements_top_wal_records 
        value_column: records
        value_type: double
        description: Total number of WAL records generated by the statement
        attribute_columns: ["dbname", "query", "queryid", "role"]
        static_attributes:
          server: "localhost:5432"

  - sql: |
      SELECT * FROM get_pgbackrest_info();
    metrics:
      - metric_name: ccp_backrest_last_diff_backup_time_since_completion_seconds 
        description: Seconds since the last completed full or differential backup. Differential is always based off last full.
        value_column: last_diff_backup
        attribute_columns: ["repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_full_backup_time_since_completion_seconds 
        description: Seconds since the last completed full backup
        value_column: last_full_backup
        attribute_columns: ["repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_incr_backup_time_since_completion_seconds
        description: |
          Seconds since the last completed full, differential or incremental backup.
          Incremental is always based off last full or differential.
        value_column: last_incr_backup
        attribute_columns: ["repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_info_backrest_repo_version 
        description: pgBackRest version number when this backup was performed
        value_column: last_info_backrest_repo_version
        attribute_columns: ["backup_type", "repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_info_backup_error
        description: An error has been encountered in the backup. Check logs for more information.
        value_column: last_info_backup_error
        attribute_columns: ["backup_type", "repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_info_backup_runtime_seconds 
        description: Total runtime in seconds of this backup
        value_column: backup_runtime_seconds
        attribute_columns: ["backup_type", "repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_last_info_repo_backup_size_bytes
        description: Actual size of only this individual backup in the pgbackrest repository
        value_column: repo_backup_size_bytes
        attribute_columns: ["backup_type", "repo"]
        static_attributes:
          server: "localhost:5432"
          stanza: "db"
      - metric_name: ccp_backrest_oldest_full_backup_time_seconds 
        description: Seconds since the oldest completed full backup
        value_column: oldest_full_backup
        attribute_columns: ["repo"]
        static_attributes:
          server: "localhost:5432"

  - sql: >
      SELECT s.datname AS dbname
      , s.xact_commit
      , s.xact_rollback
      , s.blks_read
      , s.blks_hit
      , s.tup_returned
      , s.tup_fetched
      , s.tup_inserted
      , s.tup_updated
      , s.tup_deleted
      , s.conflicts
      , s.temp_files
      , s.temp_bytes
      , s.deadlocks
      FROM pg_catalog.pg_stat_database s
      JOIN pg_catalog.pg_database d ON d.datname = s.datname
      WHERE d.datistemplate = false;
    metrics:
      - metric_name: ccp_stat_database_blks_hit 
        value_column: blks_hit
        description: Number of times disk blocks were found already in the buffer cache, so that a read was not necessary
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_database_blks_read  
        value_column: blks_read
        description: Number of disk blocks read in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_database_conflicts   
        value_column: conflicts
        description: Number of queries canceled due to conflicts with recovery in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_database_deadlocks 
        value_column: deadlocks
        description: Number of deadlocks detected in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_database_temp_bytes
        value_column: temp_bytes
        description: Total amount of data written to temporary files by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
      - metric_name: ccp_stat_database_temp_files 
        value_column: temp_files
        description: Number of rows deleted by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_tup_deleted 
        value_column: tup_deleted
        description: Number of rows deleted by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_tup_fetched 
        value_column: tup_fetched
        description: Number of rows fetched by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_tup_inserted 
        value_column: tup_inserted
        description: Number of rows inserted by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_tup_returned 
        value_column: tup_returned
        description: Number of rows returned by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_tup_updated 
        value_column: tup_updated
        description: Number of rows updated by queries in this database
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_xact_commit 
        value_column: xact_commit
        description: Number of transactions in this database that have been committed
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
   
      - metric_name: ccp_stat_database_xact_rollback 
        value_column: xact_rollback
        description: Number of transactions in this database that have been rolled back
        attribute_columns: ["dbname"]
        static_attributes:
          server: "localhost:5432"
