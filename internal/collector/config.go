// Copyright 2024 - 2025 Crunchy Data Solutions, Inc.
//
// SPDX-License-Identifier: Apache-2.0

package collector

import (
	_ "embed"
	"errors"
	"fmt"
	"regexp"

	"k8s.io/apimachinery/pkg/util/sets"
	"sigs.k8s.io/yaml"

	"github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1beta1"
)

// The contents of "logrotate.conf" as a string.
// See: https://pkg.go.dev/embed
//
//go:embed "logrotate.conf"
var logrotateConfigFormatString string

// ComponentID represents a component identifier within an OpenTelemetry
// Collector YAML configuration. Each value is a "type" followed by an optional
// slash-then-name: `type[/name]`
type ComponentID = string

// PipelineID represents a pipeline identifier within an OpenTelemetry Collector
// YAML configuration. Each value is a signal followed by an optional
// slash-then-name: `signal[/name]`
type PipelineID = string

// Config represents an OpenTelemetry Collector YAML configuration.
// See: https://opentelemetry.io/docs/collector/configuration
type Config struct {
	Exporters  map[ComponentID]any
	Extensions map[ComponentID]any
	Processors map[ComponentID]any
	Receivers  map[ComponentID]any

	Pipelines map[PipelineID]Pipeline
}

// Pipeline represents the YAML configuration of a flow of telemetry data
// through an OpenTelemetry Collector.
// See: https://opentelemetry.io/docs/collector/configuration#pipelines
type Pipeline struct {
	Extensions []ComponentID
	Exporters  []ComponentID
	Processors []ComponentID
	Receivers  []ComponentID
}

func (c *Config) ToYAML() (string, error) {
	const yamlGeneratedWarning = "" +
		"# Generated by postgres-operator. DO NOT EDIT.\n" +
		"# Your changes will not be saved.\n"

	extensions := sets.New[ComponentID]()
	pipelines := make(map[PipelineID]any, len(c.Pipelines))

	for id, p := range c.Pipelines {
		extensions.Insert(p.Extensions...)
		pipelines[id] = map[string]any{
			"exporters":  p.Exporters,
			"processors": p.Processors,
			"receivers":  p.Receivers,
		}
	}

	b, err := yaml.Marshal(map[string]any{
		"exporters":  c.Exporters,
		"extensions": c.Extensions,
		"processors": c.Processors,
		"receivers":  c.Receivers,
		"service": map[string]any{
			"extensions": sets.List(extensions), // Sorted
			"pipelines":  pipelines,
		},
	})
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}

// NewConfig creates a base config for an OTel collector container
func NewConfig(spec *v1beta1.InstrumentationSpec) *Config {
	config := &Config{
		Exporters: map[ComponentID]any{
			// TODO: Do we want a DebugExporter outside of development?
			// https://pkg.go.dev/go.opentelemetry.io/collector/exporter/debugexporter#section-readme
			DebugExporter: map[string]any{"verbosity": "detailed"},
		},
		Extensions: map[ComponentID]any{},
		Processors: map[ComponentID]any{
			// https://pkg.go.dev/go.opentelemetry.io/collector/processor/batchprocessor#section-readme
			OneSecondBatchProcessor: map[string]any{"timeout": "1s"},
			SubSecondBatchProcessor: map[string]any{"timeout": "200ms"},

			// https://pkg.go.dev/github.com/open-telemetry/opentelemetry-collector-contrib/processor/groupbyattrsprocessor#readme-compaction
			CompactingProcessor: map[string]any{},
		},
		Receivers: map[ComponentID]any{},
		Pipelines: map[PipelineID]Pipeline{},
	}

	// If there are exporters defined in the spec, add them to the config.
	if spec != nil && spec.Config != nil && spec.Config.Exporters != nil {
		for k, v := range spec.Config.Exporters {
			config.Exporters[k] = v
		}
	}

	return config
}

func generateLogrotateConfig(logFilePath string, retentionPeriod string, postrotateScript string) (string, error) {
	retentionPeriodMap, err := parseRetentionPeriodForLogrotate(retentionPeriod)
	if err != nil {
		return "", err
	}

	return fmt.Sprintf(
		logrotateConfigFormatString,
		logFilePath,
		retentionPeriodMap["number"],
		retentionPeriodMap["interval"],
		postrotateScript,
	), err
}

func parseRetentionPeriodForLogrotate(retentionPeriod string) (map[string]string, error) {
	// logrotate does not have an "hourly" interval, but if an interval is not
	// set it will rotate whenever logrotate is called, so set an empty string
	// in the config file for hourly
	unitIntervalMap := map[string]string{
		"h":    "",
		"hr":   "",
		"hour": "",
		"d":    "daily",
		"day":  "daily",
		"w":    "weekly",
		"wk":   "weekly",
		"week": "weekly",
	}

	// Define duration regex and capture matches
	durationMatcher := regexp.MustCompile(`(?P<number>\d+)\s*(?P<interval>[A-Za-zÂµ]+)`)
	matches := durationMatcher.FindStringSubmatch(retentionPeriod)

	// If three matches were not found (whole match and two submatch captures),
	// the retentionPeriod format must be invalid. Return an error.
	if len(matches) < 3 {
		return nil, errors.New("invalid retentionPeriod; must be number of hours, days, or weeks")
	}

	// Create a map with "number" and "interval" keys
	retentionPeriodMap := make(map[string]string)
	for i, name := range durationMatcher.SubexpNames() {
		if i > 0 && i <= len(matches) {
			retentionPeriodMap[name] = matches[i]
		}
	}

	// If the duration unit provided is found in the unitIntervalMap, set the
	// "interval" value to the "interval" string expected by logrotate; otherwise,
	// return an error
	if _, exists := unitIntervalMap[retentionPeriodMap["interval"]]; exists {
		retentionPeriodMap["interval"] = unitIntervalMap[retentionPeriodMap["interval"]]
	} else {
		return nil, fmt.Errorf("invalid retentionPeriod; %s is not a valid unit", retentionPeriodMap["interval"])
	}

	return retentionPeriodMap, nil
}
