// Copyright 2024 - 2025 Crunchy Data Solutions, Inc.
//
// SPDX-License-Identifier: Apache-2.0

package collector

import (
	"context"
	_ "embed"
	"fmt"
	"math"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/sets"
	"sigs.k8s.io/yaml"

	"github.com/crunchydata/postgres-operator/pkg/apis/postgres-operator.crunchydata.com/v1beta1"
)

// The contents of "logrotate.conf" as a string.
// See: https://pkg.go.dev/embed
//
//go:embed "logrotate.conf"
var logrotateConfigFormatString string

// ComponentID represents a component identifier within an OpenTelemetry
// Collector YAML configuration. Each value is a "type" followed by an optional
// slash-then-name: `type[/name]`
type ComponentID = string

// PipelineID represents a pipeline identifier within an OpenTelemetry Collector
// YAML configuration. Each value is a signal followed by an optional
// slash-then-name: `signal[/name]`
type PipelineID = string

// Config represents an OpenTelemetry Collector YAML configuration.
// See: https://opentelemetry.io/docs/collector/configuration
type Config struct {
	Exporters  map[ComponentID]any
	Extensions map[ComponentID]any
	Processors map[ComponentID]any
	Receivers  map[ComponentID]any

	Pipelines map[PipelineID]Pipeline
}

// Pipeline represents the YAML configuration of a flow of telemetry data
// through an OpenTelemetry Collector.
// See: https://opentelemetry.io/docs/collector/configuration#pipelines
type Pipeline struct {
	Extensions []ComponentID
	Exporters  []ComponentID
	Processors []ComponentID
	Receivers  []ComponentID
}

func (c *Config) ToYAML() (string, error) {
	const yamlGeneratedWarning = "" +
		"# Generated by postgres-operator. DO NOT EDIT.\n" +
		"# Your changes will not be saved.\n"

	extensions := sets.New[ComponentID]()
	pipelines := make(map[PipelineID]any, len(c.Pipelines))

	for id, p := range c.Pipelines {
		extensions.Insert(p.Extensions...)
		pipelines[id] = map[string]any{
			"exporters":  p.Exporters,
			"processors": p.Processors,
			"receivers":  p.Receivers,
		}
	}

	b, err := yaml.Marshal(map[string]any{
		"exporters":  c.Exporters,
		"extensions": c.Extensions,
		"processors": c.Processors,
		"receivers":  c.Receivers,
		"service": map[string]any{
			"extensions": sets.List(extensions), // Sorted
			"pipelines":  pipelines,
		},
	})
	return string(append([]byte(yamlGeneratedWarning), b...)), err
}

// NewConfig creates a base config for an OTel collector container
func NewConfig(spec *v1beta1.InstrumentationSpec) *Config {
	config := &Config{
		Exporters: map[ComponentID]any{
			// https://pkg.go.dev/go.opentelemetry.io/collector/exporter/debugexporter#section-readme
			DebugExporter: map[string]any{"verbosity": "detailed"},
		},
		Extensions: map[ComponentID]any{},
		Processors: map[ComponentID]any{
			// https://pkg.go.dev/go.opentelemetry.io/collector/processor/batchprocessor#section-readme
			OneSecondBatchProcessor: map[string]any{"timeout": "1s"},
			SubSecondBatchProcessor: map[string]any{"timeout": "200ms"},

			// https://pkg.go.dev/github.com/open-telemetry/opentelemetry-collector-contrib/processor/groupbyattrsprocessor#readme-compaction
			CompactingProcessor: map[string]any{},
		},
		Receivers: map[ComponentID]any{},
		Pipelines: map[PipelineID]Pipeline{},
	}

	// If there are exporters defined in the spec, add them to the config.
	if spec != nil && spec.Config != nil && spec.Config.Exporters != nil {
		for k, v := range spec.Config.Exporters {
			config.Exporters[k] = v
		}
	}

	return config
}

// AddLogrotateConfig generates a logrotate configuration and adds it to the
// provided configmap
func AddLogrotateConfig(ctx context.Context, spec *v1beta1.InstrumentationSpec,
	outInstanceConfigMap *corev1.ConfigMap, logFilePath, postrotateScript string,
) error {
	var err error
	var retentionPeriod *v1beta1.Duration

	if outInstanceConfigMap.Data == nil {
		outInstanceConfigMap.Data = make(map[string]string)
	}

	// If retentionPeriod is set in the spec, use that value; otherwise, we want
	// to use a reasonably short duration. Defaulting to 1 day.
	if spec != nil && spec.Logs != nil && spec.Logs.RetentionPeriod != nil {
		retentionPeriod = spec.Logs.RetentionPeriod
	} else {
		retentionPeriod, err = v1beta1.NewDuration("1d")
		if err != nil {
			return err
		}
	}

	outInstanceConfigMap.Data["logrotate.conf"] = generateLogrotateConfig(logFilePath,
		retentionPeriod, postrotateScript)

	return err
}

// generateLogrotateConfig generates a configuration string for logrotate based
// on the provided full log file path, retention period, and postrotate script
func generateLogrotateConfig(logFilePath string, retentionPeriod *v1beta1.Duration,
	postrotateScript string,
) string {
	number, interval := parseDurationForLogrotate(retentionPeriod)

	return fmt.Sprintf(
		logrotateConfigFormatString,
		logFilePath,
		number,
		interval,
		postrotateScript,
	)
}

// parseDurationForLogrotate takes a retention period and returns the rotate
// number and interval string that should be used in the logrotate config.
// If the retentionPeriod is less than 24 hours, the function will return the
// number of hours and "hourly"; otherwise, we will round up to the nearest day
// and return the day count and "daily"
func parseDurationForLogrotate(retentionPeriod *v1beta1.Duration) (int, string) {
	hours := math.Ceil(retentionPeriod.AsDuration().Hours())
	if hours < 24 {
		return int(hours), "hourly"
	}
	return int(math.Ceil(hours / 24)), "daily"
}
