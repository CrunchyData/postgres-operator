[
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/quick-installation/",
	"title": "Quick Installation",
	"tags": [],
	"description": "",
	"content": ":toc:\nv3.0, {docdate}\n\n== Overview\n\nThere are currently *quickstart* scripts that seek to automate\nthe deployment to popular Kubernetes environments -\n\n * link:https://github.com/CrunchyData/postgres-operator/blob/master/examples/quickstart-for-gke.sh[quickstart-for-gke.sh]\n * link:https://github.com/CrunchyData/postgres-operator/blob/master/examples/quickstart-for-ocp.sh[quickstart-for-ocp.sh]\n\nThe *quickstart-for-gke* script will deploy the operator to\na GKE Kube cluster.\n\nThe *quickstart-for-ocp* script will deploy the operator to\nan Openshift Container Platform cluster.\n\nBoth scripts assume you have a StorageClass defined for persistence.\n\nPre-compiled versions of the Operator *pgo* client are provided for the x86_64, Mac OSX, and Windows hosts.\n\n== Quickstart\n\n=== GKE/PKS\nThe *quickstart-for-gke.sh* script will allow users to set up the Postgres Operator quickly on GKE including PKS.\nThis script is tested on GKE but can be modified for use with other Kubernetes environments as well.\n\nThe script requires a few things in order to work -\n\n * wget utility installed\n * kubectl utility installed\n * StorageClass defined on your GKE instance\n\nExecuting the script will give you a default Operator deployment\nthat assumes *dynamic* storage and a storage class named *standard*,\nthings that GKE provides.\n\nThe script performs the following -\n\n * downloads the Operator configuration files\n * sets the $HOME/.pgouser file to default settings\n * deploys the Operator Deployment\n * sets your .bashrc to include the Operator environment variables\n * sets your $HOME/.bash_completion file to be the *pgo* bash_completion file\n\nA tip, if you want to set your Kube context to some particular namespace you \ncan run commands similar to this to set it to a *demo* namespace if\nthat namespace has already been created on your GKE cluster:\n....\nkubectl create -f $COROOT/examples/demo-namespace.json\nkubectl config set-context demo --cluster=gke_crunchy-a-test_us-central1-a_usera-quickstart --namespace=demo --user=gke_crunchy-a-test_us-central1-a_usera-quickstart\nkubectl config use-context demo\n....\n\nFor Mac and Windows users, pre-built *pgo* binaries are included in\nthe operator release tar ball:\n * pgo-mac is the Mac binary\n * pgo.exe is the Windows binary\n * pgo is the Linux binary\n * expenv-mac is the expenv binary for Mac\n * expenv.exe is the expenv binary for Windows\n\nCurrently the quickstart scripts are meant for Linux installs, you will\nneed to modify this script for Windows or Mac installs until we support\nand provide Windows and Mac installation scripts.\n\n=== Openshift Container Platform\n\nA similar script for installing the operator on OCP is\noffered with similar features as the GKE script.  This script is\ntested on OCP 3.7 with a StorageClass defined.\n\n== Next Steps\n\nNext, visit the link:/installation/deployment/[Deployment] page to deploy the\nOperator, verify the installation, and view various storage configurations.\n"
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/manual-installation/",
	"title": "Manual Installation",
	"tags": [],
	"description": "",
	"content": ":toc: v3.0, {docdate} == Project Structure To perform an installation of the operator, first create the project structure as follows on your host, here we assume a local directory called *odev* - .... export GOPATH=$HOME/odev mkdir -p $HOME/odev/src $HOME/odev/bin $HOME/odev/pkg mkdir -p $GOPATH/src/github.com/crunchydata/ .... Next, get a tagged release of the source code - .... cd $GOPATH/src/github.com/crunchydata git clone https://github.com/CrunchyData/postgres-operator.git cd postgres-operator git checkout 3.0 .... == Installation Prerequsites To run the operator and the *pgo* client, you will need the following - * a running Kubernetes or OpenShift cluster * the kubectl or oc clients installed in your PATH and configured to connect to the cluster (e.g. export KUBECONFIG=/etc/kubernetes/admin.conf) * a Kubernetes namespace created and set to where you want the operator installed. For this install we assume a namespace of *demo* has been created. .... kubectl create -f examples/demo-namespace.json kubectl config set-context $(kubectl config current-context) --namespace=demo kubectl config view | grep namespace .... [WARNING] ==== If you are not using the *demo* namespace, it will be required to edit the following and change the namespace where the service account and cluster role bindings will be deployed. `$COROOT/deploy/service-account.yaml` `$COROOT/deploy/cluster-role-binding.yaml` ==== Permissions are granted to the Operator by means of a Service Account called *postgres-operator*. That service account is added to the Operator deployment. The postgres-operator service account is granted cluster-admin priviledges using a cluster role binding *postgres-operator-cluster-role-binding*. See link:https://kubernetes.io/docs/admin/authorization/rbac/[here] for more details on how to enable RBAC roles and modify the scope of the permissions to suit your needs. == Basic Installation The basic installation uses the default operator configuration settings, these settings assume you want to use HostPath storage on your Kube cluster for database persistence. Other persistent options are available but require the Advanced Installation below. === Create HostPath Directory The default Persistent Volume script assumes a default HostPath directory be created called */data*: .... sudo mkdir /data sudo chown 777 /data .... Create some sample Persistent Volumes using the following script: .... export CO_NAMESPACE=demo export CO_CMD=kubectl export COROOT=$GOPATH/src/github.com/crunchydata/postgres-operator go get github.com/blang/expenv $COROOT/pv/create-pv.sh .... == Build Images \u0026 Deploy   Packaged Images   === Packaged Images To pull prebuilt versions from Dockerhub of the *postgres-operator* containers, specify the image versions, and execute the following Makefile target - .... export CO_IMAGE_PREFIX=crunchydata export CO_IMAGE_TAG=centos7-3.0 make pull .... To pull down the prebuilt *pgo* binaries, download the *tar.gz* release file from the following link - * link:https://github.com/CrunchyData/postgres-operator/releases[Github Releases] * extract (e.g. tar xvzf postgres-operator.3.0.tar.gz) .... cd $HOME tar xvzf ./postgres-operator.3.0.tar.gz .... * copy *pgo* client to somewhere in your path (e.g. cp pgo /usr/local/bin) Next, deploy the operator to your Kubernetes cluster - .... cd $COROOT make deployoperator ....     Build from Source   === Build from Source The purpose of this section is to illustrate how to build the PostgreSQL Operator from source. These are considered advanced installation steps and should be primarily used by developers or those wishing a more precise installation method. ==== Requirements The postgres-operator runs on any Kubernetes and Openshift platform that supports Custom Resource Definitions. The Operator is tested on Kubeadm and OpenShift Container Platform environments. The operator is developed with the Golang versions greater than or equal to version 1.8. See link:https://golang.org/dl/[Golang website] for details on installing golang. The Operator project builds and operates with the following containers - * link:https://hub.docker.com/r/crunchydata/pgo-lspvc/[PVC Listing Container] * link:https://hub.docker.com/r/crunchydata/pgo-rmdata/[Remove Data Container] * link:https://hub.docker.com/r/crunchydata/postgres-operator/[postgres-operator Container] * link:https://hub.docker.com/r/crunchydata/pgo-apiserver/[apiserver Container] * link:https://hub.docker.com/r/crunchydata/pgo-load/[file load Container] This Operator is developed and tested on the following operating systems but is known to run on other operating systems - * *CentOS 7* * *RHEL 7* First, install the project library dependencies. The godep dependency manager is used for this purpose. - .... cd $COROOT make setup .... Then, compile the PostgreSQL Operator using the Makefile. .... cd $COROOT make all which pgo .... Finally, deploy the operator to your Kubernetes cluster. .... cd $COROOT make deployoperator ....   == Makefile Targets The following table describes the Makefile targets - .Makefile Targets [width=\"80%\",frame=\"topbot\",options=\"header\"] |====================== |Target | Description |all | compile all binaries and build all images |setup | fetch the dependent packages required to build with |deployoperator | deploy the Operator (apiserver and postgers-operator) to Kubernetes |main | compile the postgres-operator |runmain | locally execute the postgres-operator |pgo | build the pgo binary |runpgo | run the pgo binary |runapiserver | run the apiserver binary outside of Kube |clean | remove binaries and compiled packages, restore dependencies |operatorimage | compile and build the postgres-operator Docker image |apiserverimage | compile and build the apiserver Docker image |lsimage | build the lspvc Docker image |loadimage | build the file load Docker image |rmdataimage | build the data deletion Docker image |release | build the postgres-operator release |====================== == Next Steps Next, visit the link:/installation/deployment/[Deployment] page to deploy the Operator, verify the installation, and view various storage configurations. "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/helm-chart/",
	"title": "Helm Chart",
	"tags": [],
	"description": "",
	"content": "v3.0, {docdate}\n\n== Helm Chart\n\nFirst, pull prebuilt versions from Dockerhub of the *postgres-operator* containers,\nspecify the image versions, and execute the following Makefile target -\n....\nexport CO_IMAGE_PREFIX=crunchydata\nexport CO_IMAGE_TAG=centos7-3.0\nmake pull\n....\n\nThen, build and deploy the operator using the provided Helm chart -\n....\ncd $COROOT/chart\nhelm install ./postgres-operator\nhelm ls\n....\n\n== Next Steps\n\nNext, visit the link:/installation/deployment/[Deployment] page to deploy the\nOperator, verify the installation, and view various storage configurations.\n"
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/upgrading-the-operator/",
	"title": "Upgrading the Operator",
	"tags": [],
	"description": "",
	"content": "v3.0, {docdate}   Upgrading from v2.4 to v2.5   For a full list of additions and revisions that occurred in the PostgreSQL Operator v2.5 release, please view the related release page link:https://github.com/CrunchyData/postgres-operator/releases/tag/2.5[here]. == Required Updates This section notes some required steps that will need to be taken in the process of upgrading from v2.4 to v2.5. === Configuration File It will be necessary to update your existing `pgo.yaml` configuration file where the Storage Configuration sections are concerned. The updated file for v2.5 can be found link:https://github.com/CrunchyData/postgres-operator/blob/2.5/conf/apiserver/pgo.yaml[here]. The file contained within the local installation of the Operator is located by default in the following location - .... $COROOT/conf/apiserver/pgo.yaml .... === Secrets 2.5 changed the names of the database credentials that are created by default in order to be consistent with the way new database credentials are named. It will be necessary to run the following script to update your existing clusters. This script will essentially copy the existing secrets values and create new secrets with those same values but named to the new standard. Run the script by passing in the name of an existing cluster as a parameter. .... $COROOT/bin/upgrade-secret.sh ....     Upgrading from v2.5 to v2.6   For a full list of additions and revisions that occurred in the PostgreSQL Operator v2.5 release, please view the related release page link:https://github.com/CrunchyData/postgres-operator/releases/tag/3.0[here]. == Required Updates This section notes some required steps that will need to be taken in the process of upgrading from v2.5 to v2.6. === Configuration File One update in v2.6 changed the `pgo.yaml` file through removing the Debug flag. The `Pgo.Debug` variable can now be removed from the `pgo.yaml` file as a result. The debug flag is now called `CRUNCHY_DEBUG` and is set in the `deployment.json` file as a default environment variable. === Container Resources Release 2.6 added the concept of container resource configurations to the `pgo.yaml` file. In order to specify the optional container resource configurations, add a section as follows to your `pgo.yaml` file - .... DefaultContainerResource: small ContainerResources: small: RequestsMemory: 2Gi RequestsCPU: 0.5 LimitsMemory: 2Gi LimitsCPU: 1.0 large: RequestsMemory: 8Gi RequestsCPU: 2.0 LimitsMemory: 12Gi LimitsCPU: 4.0 .... If these settings are set incorrectly or if the Kubernetes cluster cannot meet the defined memory and CPU requirements, deployments will go into a *pending* state.  === Kube RBAC Release 2.6 added a `rbac.yaml` file to capture the Kube RBAC rules. These RBAC rules allow the *apiserver* and *postgres-operator* containers access to the Kubernetes resources required for the operator to work. As part of the deployment process, it is necessary to execute the `rbac.yaml` file to set the roles and bindings required by the operator. Adjust this file to suit local security requirements. === Application RBAC Release 2.6 added an RBAC capability to secure the *pgo* application. The *pgouser* now has a role appended at the end of of each user definition as follows - .... username:password:pgoadmin testuser:testpass:pgoadmin readonlyuser:testpass:pgoreader .... These are defined in the following file - .... $COROOT/conf/apiserver/pgouser .... To match the behavior of the pre 2.6 releases, the *pgadmin* role is set on the previous user definitions, but a *readonlyuser* is now defined to test other role definitions. The roles are defined in a new file called *pgorole*. This file defines each role and the permissions for that role. By default, two roles are defined as samples - .... pgoadmin pgoreader .... Adjust these default settings to meet local security requirements. The format of this file is as follows - .... rolename: permissionA, permissionB .... These are defined in the following file - .... $COROOT/conf/apiserver/pgorole .... The complete set of permissions is documented in the link:/installation/configuration/[Configuration] document. === User Creation Release 2.6 replaced the `pgo user --add` command with the `pgo create user` command to improve consistency across command usage. Any scripts written using the older style of command require an update to use the new command syntax. === Replica CRD There is a new Kubernetes Custom Resource Definition that serves the purpose of holding replica information, called *pgreplicas*. This CRD is populated with the pgo scale command and is used to hold per-replica specific information such as the resource and storage configurations requested at run time.   "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "v3.0, {docdate}\n\n== Installation\n\nFor a quick deployment on either a GKE or OpenShift environment, visit the\nlink:/installation/quick-installation/[Quick Installation] page.\n\nFor a manual installation of the Operator on either a Kubernetes or OpenShift\nenvironment, visit the link:/installation/manual-installation/[Manual Installation]\npage.\n\nA link:/installation/helm-chart/[Helm Chart] is also provided.\n\nIf you're looking to upgrade a current PostgreSQL Operator installation, visit the\nlink:/installation/upgrading-the-operator/[Upgrading the Operator] page.\n\nAfter completing the installation steps, ensure you visit the\nlink:/installation/deployment/[Deployment] page to deploy the Operator to your\nenvironment.\n\n== Next Steps\n\nThere are many ways to configure the operator further. Some sample configurations are\ndocumented on the link:/installation/configuration/[Configuration] page.\n\nYou may also want to find out more information on how the operator is designed to work and\ndeploy. This information can be found in the link:/how-it-works/[How It Works] page.\n\nInformation can be found on the full scope of commands on the\nlink:/getting-started/[Getting Started] page.\n"
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/deployment/",
	"title": "Deployment",
	"tags": [],
	"description": "",
	"content": ":toc: v3.0, {docdate} This document details verifying the installation of the PostgreSQL Operator is successful, in addition to detailing some different storage configurations that can be made. == Verify Operator Status To verify that the operator is deployed and running, run the following: .... kubectl get pod --selector=name=postgres-operator .... You should see output similar to this: .... NAME READY STATUS RESTARTS AGE postgres-operator-56598999cd-tbg4w 2/2 Running 0 1m .... There are 2 containers in the operator pod, both should be *ready* as above. When you first run the operator, it will create the required CustomResourceDefinitions. You can view these as follows - .... kubectl get crd .... The operator creates the following Custom Resource Definitions over time as the associated commands are triggered. .... kubectl get crd NAME AGE pgbackups.cr.client-go.k8s.io 2d pgclusters.cr.client-go.k8s.io 2d pgingests.cr.client-go.k8s.io 2d pgpolicies.cr.client-go.k8s.io 2d pgreplicas.cr.client-go.k8s.io 2d pgtasks.cr.client-go.k8s.io 2d pgupgrades.cr.client-go.k8s.io 2d .... At this point, the server side of the operator is deployed and ready. The complete set of environment variables used in the installation so far are - .... export CO_IMAGE_PREFIX=crunchydata export CO_IMAGE_TAG=centos7-3.0 export GOPATH=$HOME/odev export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN export COROOT=$GOPATH/src/github.com/crunchydata/postgres-operator export CO_CMD=kubectl .... You would normally add these into your *.bashrc* at this point to be used later on or if you want to redeploy the operator. == Configure *pgo* Client The pgo command line client requires TLS for securing the connection to the operator's REST API. This configuration is performed as follows - .... export PGO_CA_CERT=$COROOT/conf/apiserver/server.crt export PGO_CLIENT_CERT=$COROOT/conf/apiserver/server.crt export PGO_CLIENT_KEY=$COROOT/conf/apiserver/server.key .... The pgo client uses Basic Authentication to authenticate to the operator REST API, for authentication, add the following `.pgouser` file to your $HOME - .... echo \"username:password\"  $HOME/.pgouser .... The *pgo* client needs the URL to connect to the operator. Depending on your Kubernetes environment this can be done the following ways.   Running Kubernetes Locally   === Running Kubernetes Locally If your local host is not set up to resolve Kubernetes Service DNS names, you can specify the operator IP address as follows - .... kubectl get service postgres-operator NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE postgres-operator NodePort 10.109.184.8  8443:30894/TCP 5m export CO_APISERVER_URL=https://10.109.184.8:8443 pgo version .... It is also possible to define a bash alias such as - .... alias setip='export CO_APISERVER_URL=https://`kubectl get service postgres-operator -o=jsonpath=\"{.spec.clusterIP}\"`:8443' .... This alias will set the `CO_APISERVER_URL` IP address for you.     Running Kubernetes Remotely   ==== Running Kubernetes Remotely Set up a port-forward tunnel from your host to the Kube remote host, specifying the operator pod - .... kubectl get pod --selector=name=postgres-operator NAME READY STATUS RESTARTS AGE postgres-operator-56598999cd-tbg4w 2/2 Running 0 8m kubectl port-forward postgres-operator-56598999cd-tbg4w 8443:8443 .... In another terminal - .... export CO_APISERVER_URL=https://127.0.0.1:8443 pgo version ....   == Verify pgo Client At this point you should be able to connect to the operator as follows - .... pgo version pgo client version 3.0 apiserver version 3.0 .... Operator commands are documented on the link:/getting-started/[Getting Started] page. == Storage Configuration Most users after they try out the operator will want to create a more customized installation and deployment of the operator using specific storage types. The operator will work with HostPath, NFS, Dynamic, and GKE Storage.   NFS   === NFS To configure the operator to use NFS for storage, a sample *pgo.yaml.nfs* file is provided. Overlay the default `pgo.yaml` file with that file - .... cp $COROOT/examples/pgo.yaml.nfs $COROOT/conf/apiserver/pgo.yaml .... Edit the *pgo.yaml* file to specify the NFS GID that is set for the NFS volume mount you will be using, the default value assumed is *nfsnobody* as the GID (65534). Update the value to meet your NFS security settings. There is currently no script available to create your NFS Persistent Volumes but you can typically modify the `$COROOT/pv/create-pv.sh` script to work with NFS.     Dynamic   === Dynamic To configure the operator to use Dynamic Storage classes for storage, a sample *pgo.yaml.storageclass* file is provided. Overlay the default *pgo.yaml* file with that file - .... cp $COROOT/examples/pgo.yaml.storageclass $COROOT/conf/apiserver/pgo.yaml .... Edit the *pgo.yaml* file to specify the storage class you will be using, the default value assumed is *standard* which is the name used by default within a GKE Kube cluster deployment. Update the value to match your storage classes. Notice that the *FsGroup* setting is required for most block storage and is set to the value of *26* since the PostgreSQL container runs as UID *26*.     GKE   === GKE Some notes for setting up GKE for the Operator deployment. ==== Install Kubectl On your host you will be working from, install the kubectl command - https://kubernetes.io/docs/tasks/tools/install-kubectl/ ==== GCP * Select your project * Create a Kube cluster in that project By default a storage class called *standard* is created. ==== Install GCloud To access the Kubernetes cluster, install the gcloud utility - .... https://cloud.google.com/sdk/downloads cd google-cloud-sdk ./install.sh .... ==== Configure Kubectl for Cluster Access .... gcloud auth login gcloud container clusters get-credentials jeff-quickstart --zone us-central1-a --project crunchy-dev-test kubectl get storageclass ....   == Next Steps There are many ways to configure the operator further. Some sample configurations are documented on the link:/installation/configuration/[Configuration] page. You may also want to find out more information on how the operator is designed to work and deploy. This information can be found in the link:/how-it-works/[How It Works] page. Information can be found on the full scope of commands on the link:/getting-started/[Getting Started] page. "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/installation/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": ":toc: v3.0, {docdate} == Overview This document describes how to configure the operator beyond the default configurations in addition to detailing what the configuration settings mean. == Openshift Container Platform To run the Operator on Openshift Container Platform note the following requirements - * Openshift Container Platform 3.7 or greater is required due to the dependence on Custom Resource Definitions. * The `CO_CMD` environment variable should be set to `oc` when operating in an Openshift environment. == Security Configuration === Kube RBAC The *apiserver* and *postgres-operator* containers access Kubernetes resources and therefore require privileges for successful Kubernetes interactions. The `rbac.yaml` file includes a set of roles and bindings that allow the operator to work. These are fine grained controls that you can adjust to your local Kubernetes cluster depending on specific security requirements. The `rbac.yaml` file is executed when the operator is first deployed to the Kubernetes cluster. Permissions are granted to the Operator by means of a Service Account called *postgres-operator*. That service account is added through the Operator deployment. [WARNING] ==== If you are not using the *demo* namespace, it will be required to edit the following and change the namespace where the service account and cluster role bindings will be deployed. `$COROOT/deploy/service-account.yaml` `$COROOT/deploy/cluster-role-binding.yaml` ==== See link:https://kubernetes.io/docs/admin/authorization/rbac/[here] for more details on how to enable RBAC roles and modify the scope of the permissions to suit your needs.  === Basic Authentication Basic authentication between the host and the apiserver is required. It will be necessary to configure the pgo client to specify a basic authentication username and password through the creation a file in the user's home directory named `.pgouser`. It will look similar to this, and contain only a single line - .... username:password .... The above excerpt specifies a username of *username* and a password of *password*. These values will be read by the *pgo* client and passed to the *apiserver* on each REST API call. For the *apiserver*, a list of usernames and passwords is specified in the *apiserver-conf-secret* Secret. The values specified in a deployment are found in the following location - .... $COROOT/conf/apiserver/pgouser .... The sample configuration for `pgouser` is as follows - .... username:password testuser:testpass .... Modify these values to be unique to your environment. If the username and password passed by clients to the *apiserver* do not match, the REST call will fail and a log message will be produced in the *apiserver* container log. The client will receive a 401 HTTP status code if they are not able to authenticate. If the `pgouser` file is not found in the *home* directory of the pgo user then the next searched location is `/etc/pgo/pgouser`. If the file is not found in either of the locations, the pgo client searches for the existence of a `PGOUSER` environment variable in order to locate a path to the basic authentication file. Basic authentication can be entirely disabled by setting the BasicAuth setting in the `pgo.yaml` configuration file to `false`. === Configure TLS TLS is used to secure communications to the apiserver. Sample keys and certifications that can be used by TLS are found here - .... $COROOT/conf/apiserver/server.crt $COROOT/conf/apiserver/server.key .... If you want to generate your own keys, you can use the script found in - .... $COROOT/bin/make-certs.sh .... The *pgo* client is required to use keys to connect to the *apiserver*. Specify the keys for pgo by setting the following environment variables - .... export PGO_CA_CERT=$COROOT/conf/apiserver/server.crt export PGO_CLIENT_CERT=$COROOT/conf/apiserver/server.crt export PGO_CLIENT_KEY=$COROOT/conf/apiserver/server.key .... The sample server keys are used as the client keys; adjust to suit security requirements. For the *apiserver TLS configuration*, the keys are included in the *apiserver-conf-secret* Secret when the apiserver is deployed. See the `$COROOT/deploy/deploy.sh script` which is where the secret is created. The apiserver listens on port 8443 (e.g. https://postgres-operator:8443) by default. You can set `InsecureSkipVerify` to *true* by setting the `NO_TLS_VERIFY` environment variable in the `deployment.json` file to *true*. By default this value is set to *false* if you do not specify a value. === pgo RBAC The pgo command line utility talks to the apiserver REST API instead of the Kubernetes API. It is therefore necessary for the pgo client to make use of RBAC configuration. Starting in Release 3.0, the */conf/apiserver/pgorole* is used to define some sample pgo roles, *pgadmin* and *pgoreader*. These roles are meant as examples that you can configure to suit security requirements as necessary. The *pgadmin* role grants a user authorization to all pgo commands. The *pgoreader* only grants access to pgo commands that display information such as `pgo show cluster`. The `pgorole` file is read at start up time when the operator is deployed to the Kubernetes cluster. Also, the `pgouser` file now includes the role that is assigned to a specific user as follows - .... username:password:pgoadmin testuser:testpass:pgoadmin readonlyuser:testpass:pgoreader .... The following list shows the current complete list of possible pgo permissions - .pgo Permissions [width=\"60%\",frame=\"topbot\",options=\"header\"] |====================== |Permission | Description |ShowCluster | allow *pgo show cluster* |CreateCluster | allow *pgo create cluster* |TestCluster | allow *pgo test mycluster* |ShowBackup | allow *pgo show backup* |CreateBackup | allow *pgo backup mycluster* |DeleteBackup | allow *pgo delete backup mycluster* |Label | allow *pgo label* |Load | allow *pgo load* |CreatePolicy | allow *pgo create policy* |DeletePolicy | allow *pgo delete policy* |ShowPolicy | allow *pgo show policy* |ApplyPolicy | allow *pgo apply policy* |ShowPVC | allow *pgo show pvc* |CreateUpgrade | allow *pgo upgrade* |ShowUpgrade | allow *pgo show upgrade* |DeleteUpgrade | allow *pgo delete upgrade* |CreateUser | allow *pgo create user* |CreateFailover| allow *pgo failover* |User | allow *pgo user* |Version | allow *pgo version* |====================== If the user is unauthorized for a pgo command, the user will get back this response - .... FATA[0000] Authentication Failed: 40 .... === *apiserver* Configuration The postgres-operator pod includes the apiserver which is a REST API that pgo users are able to communicate with. The apiserver uses the following configuration files found in `$COROOT/conf/apiserver` to determine how the Operator will provision PostgreSQL containers - .... $COROOT/conf/apiserver/pgo.yaml $COROOT/conf/apiserver/pgo.lspvc-template.json $COROOT/conf/apiserver/pgo.load-template.json .... Note that the default pgo.yaml file assumes you are going to use *HostPath* Persistent Volumes for your storage configuration. It will be necessary to adjust this file for NFS or other storage configurations. Some examples of how are listed in the manual installation document. The version of PostgreSQL container the Operator will deploy is determined by the *CCPImageTag* setting in the `$COROOT/conf/apiserver/pgo.yaml` configuration file. By default, this value is set to the latest release of the Crunchy Container Suite. ==== *pgo.yaml* The default pgo.yaml configuration file, included in `$COROOT/conf/apiserver/pgo.yaml`, looks like this - [source,yaml] .... BasicAuth: true Cluster: CCPImageTag: centos7-10.4-1.8.3 Port: 5432 User: testuser Database: userdb PasswordAgeDays: 60 PasswordLength: 8 Strategy: 1 Replicas: 0 ArchiveMode: false ArchiveTimeout: 60 PrimaryStorage: storage1 BackupStorage: storage1 ReplicaStorage: storage1 Storage: storage1: AccessMode: ReadWriteMany Size: 200M StorageType: create storage2: AccessMode: ReadWriteMany Size: 333M StorageType: create storage3: AccessMode: ReadWriteMany Size: 440M StorageType: create DefaultContainerResource: small ContainerResources: small: RequestsMemory: 2Gi RequestsCPU: 0.5 LimitsMemory: 2Gi LimitsCPU: 1.0 large: RequestsMemory: 8Gi RequestsCPU: 2.0 LimitsMemory: 12Gi LimitsCPU: 4.0 Pgo: Audit: false Metrics: false LSPVCTemplate: /config/pgo.lspvc-template.json CSVLoadTemplate: /config/pgo.load-template.json COImagePrefix: crunchydata COImageTag: centos7-2.7 .... Values in the pgo configuration file have the following meaning: .pgo Configuration File Definitions [width=\"90%\",cols=\"m,2\",frame=\"topbot\",options=\"header\"] |====================== |Setting | Definition |BasicAuth | if set to *true* will enable Basic Authentication |Cluster.CCPImageTag |newly created containers will be based on this image version (e.g. centos7-10.4-1.8.3), unless you override it using the --ccp-image-tag command line flag |Cluster.Port | the PostgreSQL port to use for new containers (e.g. 5432) |Cluster.User | the PostgreSQL normal user name |Cluster.Strategy | sets the deployment strategy to be used for deploying a cluster, currently there is only strategy *1* |Cluster.Replicas | the number of cluster replicas to create for newly created clusters |Cluster.Policies | optional, list of policies to apply to a newly created cluster, comma separated, must be valid policies in the catalog |Cluster.PasswordAgeDays | optional, if set, will set the VALID UNTIL date on passwords to this many days in the future when creating users or setting passwords, defaults to 60 days |Cluster.PasswordLength | optional, if set, will determine the password length used when creating passwords, defaults to 8 |Cluster.ArchiveMode | optional, if set to true will enable archive logging for all clusters created, default is false. |Cluster.ArchiveTimeout | optional, if set, will determine the archive timeout setting used when ArchiveMode is true, defaults to 60 seconds |PrimaryStorage |required, the value of the storage configuration to use for the primary PostgreSQL deployment |BackupStorage |required, the value of the storage configuration to use for backups |ReplicaStorage |required, the value of the storage configuration to use for the replica PostgreSQL deployments |Storage.storage1.StorageClass |for a dynamic storage type, you can specify the storage class used for storage provisioning(e.g. standard, gold, fast) |Storage.storage1.AccessMode |the access mode for new PVCs (e.g. ReadWriteMany, ReadWriteOnce, ReadOnlyMany). See below for descriptions of these. |Storage.storage1.Size |the size to use when creating new PVCs (e.g. 100M, 1Gi) |Storage.storage1.StorageType |supported values are either *dynamic*, *existing*, *create*, or *emptydir*, if not supplied, *emptydir* is used |Storage.storage1.Fsgroup | optional, if set, will cause a *SecurityContext* and *fsGroup* attributes to be added to generated Pod and Deployment definitions |Storage.storage1.SupplementalGroups | optional, if set, will cause a SecurityContext to be added to generated Pod and Deployment definitions |DefaultContainerResource |optional, the value of the container resources configuration to use for all database containers, if not set, no resource limits or requests are added on the database container |ContainerResources.small.RequestsMemory | request size of memory in bytes |ContainerResources.small.RequestsCPU | request size of CPU cores |ContainerResources.small.LimitsMemory | request size of memory in bytes |ContainerResources.small.LimitsCPU | request size of CPU cores |ContainerResources.large.RequestsMemory | request size of memory in bytes |ContainerResources.large.RequestsCPU | request size of CPU cores |ContainerResources.large.LimitsMemory | request size of memory in bytes |ContainerResources.large.LimitsCPU | request size of CPU cores |Pgo.LSPVCTemplate | the PVC lspvc template file that lists PVC contents |Pgo.LoadTemplate | the load template file used for load jobs |Pgo.COImagePrefix | image tag prefix to use for the Operator containers |Pgo.COImageTag | image tag to use for the Operator containers |Pgo.Audit | boolean, if set to true will cause each apiserver call to be logged with an *audit* marking |Pgo.Metrics | boolean, if set to true will cause each new cluster to include crunchy-collect as a sidecar container for metrics collection, if set to false (default), users can still add metrics on a cluster-by-cluster basis using the pgo command flag --metrics |====================== ==== Storage Configurations You can now define n-number of Storage configurations within the *pgo.yaml* file. Those Storage configurations follow these conventions - * they must have lowercase name (e.g. storage1) * they must be unique names (e.g. mydrstorage, faststorage, slowstorage) These Storage configurations are referenced in the BackupStorage, ReplicaStorage, and PrimaryStorage configuration values. However, there are command line options in the *pgo* client that will let a user override these default global values to offer you the user a way to specify very targeted storage configurations when needed (e.g. disaster recovery storage for certain backups). You can set the storage AccessMode values to the following - * *ReadWriteMany* - mounts the volume as read-write by many nodes * *ReadWriteOnce* - mounts the PVC as read-write by a single node * *ReadOnlyMany* - mounts the PVC as read-only by many nodes These Storage configurations are validated when the *pgo-apiserver* starts, if a non-valid configuration is found, the apiserver will abort. These Storage values are only read at *apiserver* start time. The following StorageType values are possible - * *dynamic* - this will allow for dynamic provisioning of storage using a StorageClass. * *existing* - This setting allows you to use a PVC that already exists. For example, if you have a NFS volume mounted to a PVC, all PostgreSQL clusters can write to that NFS volume mount via a common PVC. When set, the Name setting is used for the PVC. * *create* - This setting allows for the creation of a new PVC for each PostgreSQL cluster using a naming convention of *clustername*. When set, the *Size*, *AccessMode* settings are used in constructing the new PVC. * *emptydir* - If a StorageType value is not defined, *emptydir* is used by default. This is a volume type thatâ€™s created when a pod is assigned to a node and exists as long as that pod remains running on that node; it is deleted as soon as the pod is manually deleted or removed from the node. The operator will create new PVCs using this naming convention: *dbname* where *dbname* is the database name you have specified. For example, if you run: .... pgo create cluster example1 .... It will result in a PVC being created named *example1* and in the case of a backup job, the pvc is named *example1-backup* There are currently 3 sample pgo configuration files provided for users to use as a starting configuration - * `pgo.yaml.emptydir` - this configuration specifies *emptydir* storage to be used for databases * `pgo.yaml.nfs` - this configuration specifies *create* storage to be used, this is used for NFS storage for example where you want to have a unique PVC created for each database * `pgo.yaml.dynamic` - this configuration specifies *dynamic* storage to be used, namely a *storageclass* that refers to a dynamic provisioning strorage such as StorageOS or Portworx, or GCE. ==== Overriding Container Resources Configuration Defaults In the *pgo.yaml* configuration file you have the option to configure a default container resources configuration that when set will add CPU and memory resource limits and requests values into each database container when the container is created. You can also override the default value using the `--resources-config` command flag when creating a new cluster - .... pgo create cluster testcluster --resources-config=large .... Note, if you try to allocate more resources than your host or Kube cluster has available then you will see your pods wait in a *Pending* status. The output from a `kubectl describe pod` command will show output like this in this event - .... Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 49s (x8 over 1m) default-scheduler No nodes are available that match all of the predicates: Insufficient memory (1). .... ==== Overriding Storage Configuration Defaults .... pgo create cluster testcluster --storage-config=bigdisk .... That example will create a cluster and specify a storage configuration of *bigdisk* to be used for the primary database storage. The replica storage will default to the value of ReplicaStorage as specified in *pgo.yaml*. .... pgo create cluster testcluster2 --storage-config=fastdisk --replica-storage-config=slowdisk .... That example will create a cluster and specify a storage configuration of *fastdisk* to be used for the primary database storage, while the replica storage will use the storage configuration *slowdisk*. .... pgo backup testcluster --storage-config=offsitestorage .... That example will create a backup and use the *offsitestorage* storage configuration for persisting the backup. ==== Disaster Recovery Using Storage Configurations A simple mechanism for partial disaster recovery can be obtained by leveraging network storage, Kubernetes storage classes, and the storage configuration options within the Operator. For example, if you define a Kubernetes storage class that refers to a storage backend that is running within your disaster recovery site, and then use that storage class as a storage configuration for your backups, you essentially have moved your backup files automatically to your disaster recovery site thanks to network storage. image::/Operator-DR-Storage.png[Operator Storage] === *postgres-operator* Container Configuration To enable *debug* level messages from the operator pod, set the `CRUNCHY_DEBUG` environment variable to *true* within its deployment file `deployment.json`. ==== Operator Templates The database and cluster Kubernetes objects that get created by the operator are based on JSON templates that are added into the operator deployment by means of a mounted volume. The templates are located in the `$COROOT/conf/postgres-operator` directory and are added into a config map which is mounted by the operator deployment. == bash Completion There is a bash completion file that is included for users to try located in the repository at `examples/pgo-bash-completion`. To use it - .... cp $COROOT/examples/pgo-bash-completion /etc/bash_completion.d/pgo su - $USER .... == REST API Because the *apiserver* implements a REST API, it is possible to integrate with it using your own application code. To demonstrate this, the following *curl* commands show the API usage - *pgo version* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/version .... *pgo show policy all* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/policies/all .... *pgo show pvc danger* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/pvc/danger .... *pgo show cluster mycluster* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/clusters/mycluster .... *pgo show upgrade mycluster* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/upgrades/mycluster .... *pgo test mycluster* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/clusters/test/mycluster .... *pgo show backup mycluster* .... curl -v -X GET -u readonlyuser:testpass -H \"Content-Type: application/json\" --insecure https://10.101.155.218:8443/backups/mycluster .... == Deploying pgpool One option with pgo is enabling the creation of a pgpool deployment in addition to the PostgreSQL cluster. Running pgpool is a logical inclusion when the Kubernetes cluster includes both a primary database in addition to some number of replicas deployed. The current pgpool configuration deployed by the operator only works when both a primary and a replica are running. When a user creates the cluster a command flag can be passed as follows to enable the creation of the pgpool deployment. .... pgo create cluster cluster1 --pgpool pgo scale cluster1 .... This will cause the operator to create a Deployment that includes the *crunchy-pgpool* container along with a replica. That container will create a configuration that will perform SQL routing to your cluster services, both for the primary and replica services. Pgpool examines the SQL it receives and routes the SQL statement to either the primary or replica based on the SQL action. Specifically, it will send writes and updates to only the *primary* service. It will send read-only statements to the *replica* service. When the operator deploys the pgpool container, it creates a secret (e.g. mycluster-pgpool-secret) that contains pgpool configuration files. It fills out templated versions of these configuration files specifically for this PostgreSQL cluster. Part of the pgpool deployment also includes creating a `pool_passwd` file that will allow the *testuser* credential to authenticate to pgpool. Adding additional users to the pgpool configuration currently requires human intervention specifically creating a new pgpool secret and bouncing the pgpool pod to pick up the updated secret. Future operator releases will attempt to provide *pgo* commands to let you automate the addition or removal of a pgpool user. Currently to update a pgpool user within the `pool_passwd` configuration file, it is necessary to copy the existing files from the secret to your local system, update the credentials in `pool_passwd` with the new user credentials, recreate the pgpool secret, and finally restart the pgpool pod to pick up the updated configuration files. As an example - .... kubectl cp demo/wed10-pgpool-6cc6f6598d-wcnmf:/pgconf/ /tmp/foo .... That command gets a running set of secret pgpool configuration files and places them locally on your system for you to edit. *pgpool* requires a specially formatted password credential to be placed into `pool_passwd`. There is a golang program included in `$COROOT/golang-examples/gen-pgpool-pass.go` that, when run, will generate the value to use within the *pgpool_passwd* configuration file. .... go run $COROOT/golang-examples/gen-pgpool-pass.go Enter Username: testuser Enter Password: Password typed: e99Mjt1dLz hash of password is [md59c4017667828b33762665dc4558fbd76] .... The value *md59c4017667828b33762665dc4558fbd76* is what you will use in the *pool_passwd* file. Then, create the new secrets file based on those updated files - .... $COROOT/bin/create-pgpool-secrets.sh .... Lastly for pgpool to pick up the new secret file, delete the existing deployment pod - .... kubectl get deployment wed-pgpool kubectl delete pod wed10-pgpool-6cc6f6598d-wcnmf .... The pgpool deployment will spin up another pgpool which will pick up the updated secret file. "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/contributing/",
	"title": "Contributing",
	"tags": [],
	"description": "",
	"content": "v3.0, {docdate}\n\n== Getting Started\n\nWelcome! Thank you for your interest in contributing. Before submitting a new link:https://github.com/CrunchyData/postgres-operator/issues/new[issue]\nor link:https://github.com/CrunchyData/postgres-operator/pulls[pull request] to the link:https://github.com/CrunchyData/postgres-operator/[Crunchy Data\nPostgreSQL Operator] project on GitHub, *please review any open or closed issues* link:https://github.com/crunchydata/postgres-operator/issues[here]\nin addition to any existing open pull requests.\n\n== Documentation\n\nThe documentation website (located at https://crunchydata.github.io/postgres-operator/) is generated using link:https://gohugo.io/[Hugo] and\nlink:https://pages.github.com/[GitHub Pages]. If you would like to build the documentation locally, view the\nlink:https://gohugo.io/getting-started/installing/[official Installing Hugo] guide to set up Hugo locally. You can then start the server by\nrunning the following commands -\n\n....\ncd $COROOT/hugo/\nvi config.toml\nhugo server\n....\n\nWhen you edit *config.toml*, you'll set `baseURL = \"/\"`. This will make the local version of the Hugo server accessible by default from\n`localhost:1313`. Once you've run `hugo server`, that will let you interactively make changes to the documentation as desired and view the updates\nin real-time.\n\n*When you're ready to commit a change*, please view and run the script located at `$COROOT/generate-docs.sh` which will automatically generate a new\nset of webpages using Hugo that will update the live website after the change has been committed to the repository.\n"
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/how-it-works/",
	"title": "How it Works",
	"tags": [],
	"description": "",
	"content": ":toc: v3.0, {docdate} == Reference Architecture So, what does the Postgres Operator actually deploy when you create a cluster? image::/OperatorReferenceDiagram.png[Operator Reference Diagram] On this diagram, objects with dashed lines are components that are optionally deployed as part of a PostgreSQL Cluster by the operator. Objects with solid lines are the fundamental and required components. For example, within the Primary Deployment, the *metrics* container is completely optional. That component can be deployed using either the operator configuration or command line arguments if you want to cause metrics to be collected from the Postgres container. Replica deployments are similar to the primary deployment but are optional. A replica is not required to be created unless the capability for one is necessary. As you scale up the Postgres cluster, the standard set of components gets deployed and replication to the primary is started. Notice that each cluster deployment gets its own unique Persistent Volumes. Each volume can use different storage configurations which is quite powerful. == Custom Resource Definitions Kubernetes Custom Resource Definitions are used in the design of the PostgreSQL Operator to define the following - * Cluster - *pgclusters* * Backup - *pgbackups* * Upgrade - *pgupgrades* * Policy - *pgpolicies* * Tasks - *pgtasks* == Command Line Interface The pgo command line interface (CLI) is used by a normal end-user to create databases or clusters, or make changes to existing databases. The CLI interacts with the *apiserver* REST API deployed within the *postgres-operator* deployment. From the CLI, users can view existing clusters that were deployed using the CLI and Operator. Objects that were not previously created by the Crunchy Operator are now viewable from the CLI. == Operator Deployment The PostgreSQL Operator runs within a Deployment in the Kubernetes cluster. An administrator will deploy the operator deployment using the provided script. Once installed and running, the Operator pod will start watching for certain defined events. The operator watches for create/update/delete actions on the *pgcluster* custom resource definitions. When the CLI creates for example a new *pgcluster* custom resource definition, the operator catches that event and creates pods and services for that new cluster request. == CLI Design The CLI uses the cobra package to implement CLI functionality like help text, config file processing, and command line parsing. The *pgo* client is essentially a REST client which communicates to the *pgo-apiserver* REST server running within the Operator pod. In some cases you might want to split the apiserver out into its own Deployment but the default deployment has a consolidated pod that contains both the apiserver and operator containers simply for convenience of deployment and updates. === Verbs A user works with the CLI by entering verbs to indicate what they want to do, as follows. [source,bash] ---- pgo show cluster all pgo delete cluster db1 db2 db3 pgo create cluster mycluster ---- In the above example, the *show*, *backup*, *delete*, and *create* verbs are used. The CLI is case sensitive and supports only lowercase. == Affinity You can have the Operator add an affinity section to a new Cluster Deployment if you want to cause Kubernetes to attempt to schedule a primary cluster to a specific Kubernetes node. You can see the nodes on your Kube cluster by running the following - .... kubectl get nodes .... You can then specify one of those names (e.g. kubeadm-node2) when creating a cluster - .... pgo create cluster thatcluster --node-name=kubeadm-node2 .... The affinity rule inserted in the Deployment will used a *preferred* strategy so that if the node were down or not available, Kube would go ahead and schedule the Pod on another node. You can always view the actual node your cluster pod is scheduled on through the following command. .... kubectl get pod -o wide .... When you scale up a Cluster and add a replica, the scaling will take into account the use of `--node-name`. If it sees that a cluster was created with a specific node name, then the replica Deployment will add an affinity rule to attempt to schedule the replica on a different node than the node the primary is schedule on. This provides a simple version of high availability and causes the primary and replicas to not live on the same Kubernetes node. == Debugging To see if the operator pod is running enter the following - [source,bash] .... kubectl get pod -l 'name=postgres-operator' .... To verify the operator is running and has deployed the Custom Resources execute the following - .... kubectl get crd .... The full list of CRDs that are created over time are shown below. .... NAME KIND pgbackups.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io pgclusters.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io pgpolicies.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io pgpolicylogs.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io pgupgrades.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io pgtasks.cr.client-go.k8s.io CustomResourceDefinition.v1beta1.apiextensions.k8s.io .... == Persistent Volumes Currently, the operator does not delete persistent volumes by default. Instead, it deletes the claims on the volumes. Starting with release 2.4, the Operator will create Jobs that actually run *rm* commands on the data volumes before actually removing the Persistent Volumes if the user passes a `--delete-data ` flag when deleting a database cluster. Likewise, if the user passes `--delete-backups` during cluster deletion a Job is created to remove all the backups for a cluster include the related Persistent Volume. == PostgreSQL Operator Deployment Strategies This section describes the various deployment strategies offered by the operator. A deployment in this case is the set of objects created in Kubernetes when a custom resource definition of type *pgcluster* is created. CRDs are created by the pgo client command and acted upon by the postgres operator. === Strategies To support different types of deployments, the operator supports multiple strategy implementations. Currently there is only a default *cluster* strategy. In the future, more deployment strategies will be supported to offer users more customization to what they see deployed in their Kubernetes cluster. Being open source, users can also write their own strategy! === Specifying a Strategy In the pgo client configuration file, there is a `CLUSTER.STRATEGY `setting. The current value of the default strategy is *1*. If you don't set that value, the default strategy is assumed. If you set that value to something not supported, the operator will log an error. === Strategy Template Files Each strategy supplies its set of templates used by the operator to create new pods, services, etc. When the operator is deployed, part of the deployment process is to copy the required strategy templates into a ConfigMap (*operator-conf*) that gets mounted into `/operator-conf` within the operator pod. The directory structure of the strategy templates is as follows - .... |-- backup-job.json |-- cluster | |-- 1 | |-- cluster-deployment-1.json | |-- cluster-replica-deployment-1.json | |-- cluster-service-1.json | |-- pvc.json .... In this structure, each strategy's templates live in a subdirectory that matches the strategy identifier. The default strategy templates are denoted by the value of *1* in the directory structure above. If you add another strategy, the file names *must* be unique within the entire strategy directory. This is due to the way the templates are stored within the ConfigMap. === Default Cluster Deployment Strategy (1) Using the default cluster strategy, a *cluster* when created by the operator will create the following on a Kubernetes cluster - * deployment running a Postgres *primary* container with replica count of 1 * service mapped to the *primary* Postgres database * service mapped to the *replica* Postgres database * PVC for the *primary* will be created if not specified in configuration, this assumes you are using a non-shared volume technology (e.g. Amazon EBS), if the `CLUSTER.PVC_NAME` value is set in your configuration then a shared volume technology is assumed (e.g. HostPath or NFS), if a PVC is created for the primary, the naming convention is *clustername* where clustername is the name of your cluster. If you want to add a Postgres replica to a cluster, you will *scale* the cluster. For each *replica-count*, a Deployment will be created that acts as a PostgreSQL replica. This is very different than using a StatefulSet to scale up PostgreSQL. Why would you do it this way? Imagine a case where you want different parts of your PostgreSQL cluster to use different storage configurations,. With this method, it can be done through using specific placement and deployments of each part of the cluster. This same concept applies to node selection for the PostgreSQL cluster components. The Operator will let you define precisely which node that the PostgreSQL component should be placed upon using node affinity rules. === Cluster Deletion When you run the following, the cluster and its services will be deleted. However, the data files and backup files will remain as well as the PVCs for this cluster. .... pgo delete cluster mycluster .... However, to remove the data files from the PVC you can pass the following flag - .... --delete-data .... This causes a workflow to be started to remove the data files on the primary cluster deployment PVC. The following flag will cause *all* of the backup files to be removed. .... --delete-backups .... The data removal workflow includes the following steps - * create a pgtask CRD to hold the PVC name and cluster name to be removed * the CRD is watched, and on an ADD will cause a Job to be created that will run the *rmdata* container using the PVC name and cluster name as parameters which determine the PVC to mount, and the file path to remove under that PVC * the *rmdata* Job is watched by the Operator, and upon a successful status completion the actual PVC is removed This workflow insures that a PVC is not removed until all the data files are removed. Also, a Job was used for the removal of files since that can be a time consuming task. The files are removed by the *rmdata* container which essentially issues the following command to remove the files - .... rm -rf /pgdata/.... === Custom Postgres Configurations Starting in release 2.5, users and administrators can specify a custom set of Postgres configuration files be used when creating a new Postgres cluster. The configuration files you can change include - * postgresql.conf * pg_hba.conf * setup.sql Different configurations for PostgreSQL might be defined for the following - * OLTP types of databases * OLAP types of databases * High Memory * Minimal Configuration for Development * Project Specific configurations * Special Security Requirements ==== Global ConfigMap If you create a *configMap* called *pgo-custom-pg-config* with any of the above files within it, new clusters will use those configuration files when setting up a new database instance. You do *NOT* have to specify all of the configuration files. It is entirely up to your use case to determine which to use. An example set of configuration files and a script to create the global configMap is found at - .... $COROOT/examples/custom-config .... If you run the *create.sh* script there, it will create the configMap that will include the PostgreSQL configuration files within that directory. ==== Config Files Purpose The *postgresql.conf* file is the main Postgresql configuration file that allows the definition of a wide variety of tuning parameters and features. The *pg_hba.conf* file is the way Postgresql secures client access. The *setup.sql* file is a Crunchy Container Suite configuration file used to initially populate the database after the initial *initdb* is run when the database is first created. Changes would be made to this if you wanted to define which database objects are created by default. ==== Granular Config Maps Granular config maps can be defined if it is necessary to use a different set of configuration files for different clusters rather than having a single configuration (e.g. Global Config Map). A specific set of ConfigMaps with their own set of PostgreSQL configuration files can be created. When creating new clusters, a `--custom-config` flag can be passed along with the name of the ConfigMap which will be used for that specific cluster or set of clusters. ==== Defaults If there's no reason to change the default PostgreSQL configuration files that ship with the Crunchy Postgres container, there's no requirement to. In this event, continue using the Operator as usual and avoid defining a global configMap. ==== Labeling When a custom configMap is used in cluster creation, the Operator labels the primary Postgres Deployment with a label of *custom-config* and a value of what configMap was used when creating the database. Commands coming in future releases will take advantage of this labeling. === Metrics Collection If you add a *--metrics* flag to *pgo create cluster* it will cause the *crunchy-collect* container to be added to your Postgres cluster. That container requires you run the *crunchy-metrics* containers as defined within the *crunchy-containers* project. The *prometheus push gateway* that is deployed as part of the *crunchy-metrics* example is a current requirement for the metrics solution. This will change in an upcoming release of the *crunchy-containers* project and there will no longer be a requirement for the push gateway to be deployed. See link:https://github.com/CrunchyData/crunchy-containers/blob/master/docs/examples.adoc#metrics-collection[the crunchy-containers Metrics example] for more details on setting up the *crunchy-metrics* solution. "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": ":toc: v3.0, {docdate} == pgo Commands Prior to using *pgo*, users will need to specify the *postgres-operator* URL as follows: .... kubectl get service postgres-operator NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE postgres-operator 10.104.47.110  8443/TCP 7m export CO_APISERVER_URL=https://10.104.47.110:8443 pgo version .... === pgo version To see what version of pgo client and postgres-operator you are running, use the following - .... pgo version .... === pgo create cluster To create a database, use the following - .... pgo create cluster mycluster .... A more complex example is to create a *series* of clusters such as - .... pgo create cluster xraydb --series=3 --labels=project=xray --policies=xrayapp,rlspolicy .... In the example above, we provision 3 clusters that have a number appended into their resulting cluster name, apply a user defined label to each cluster, and also apply user defined policies to each cluster after they are created. You can then view that database as - .... pgo show cluster mydatabase .... Also, if you like to see JSON formatted output, add the *-o json* flag - .... pgo show cluster mydatabase -o json .... The output will give you the current status of the database pod and the IP address of the database service. If you have *psql* installed on your test system you can connect to the database using the service IP address - .... psql -h 10.105.121.12 -U postgres postgres .... User credentials are generated through Kubernetes Secrets automatically for the *testuser*, *primaryuser* and *postgres* accounts. The generated passwords can be viewed by running the `pgo show cluster` command with the `--show-secrets` flag. More details are available on user management below.  You can view *all* databases using the special keyword *all* - .... pgo show cluster all .... You can filter the results based on the Postgres Version - .... pgo show cluster all --version=9.6.2 .... You can also add metrics collection to a cluster by using the *--metrics* command flag as follows - .... pgo create cluster testcluster --metrics .... This command flag causes a *crunchy-collect* container to be added to the database cluster pod and enables metrics collection on that database pod. For this to work, you will need to configure the Crunchy metrics example as found in the Crunchy Container Suite. New clusters typically pick up the container image version to use based on the pgo configuration file's `CCP_IMAGE_TAG` setting. You can override this value using the *--ccp-image-tag* command line flag - .... pgo create cluster mycluster --ccp-image-tag=centos7-9.6.5-1.6.0 .... You can also add a pgpool deployment into a cluster by using the *--pgpool* command flag as follows: .... pgo create cluster testcluster --pgpool .... This will cause a *crunchy-pgpool* container to be started and initially configured for a cluster and the *testuser* cluster credential. See below for more details on running a pgpool deployment as part of your cluster. You can also enable archive logging into a dedicated PVC by using the *--archive* command flag as follows: .... pgo create cluster testcluster --archive .... This will cause a new PVC to be created to hold archive logs. Space is consumed by these logs but archives enable you to perform Point-In-Time-Recovery. === pgo backup You can start a backup job for a cluster as follows: .... pgo backup mycluster .... You can view the backup: .... pgo show backup mycluster .... View the PVC folder and the backups contained therein: .... pgo show pvc mycluster-backup pgo show pvc mycluster-backup --pvc-root=mycluster-backups .... The output from this command is important in that it can let you copy/paste a backup snapshot path and use it for restoring a database or essentially cloning a database with an existing backup archive. For example, to restore a database from a backup archive: .... pgo create cluster restoredb --backup-path=mycluster-backups/2017-03-27-13-56-49 --backup-pvc=mycluster --secret-from=mycluster .... This will create a new database called *restoredb* based on the backup found in *mycluster-backups/2017-03-27-13-56-49* and the secrets of the *mycluster* cluster. Selectors can be used to perform backups as well, for example: .... pgo backup --selector=project=xray .... In this example, any cluster that matches the selector will cause a backup job to be created. When you request a backup, *pgo* will prompt you if you want to proceed because this action will delete any existing backup job for this cluster that might exist. The backup files will still be left intact but the actual Kubernetes Job will be removed prior to creating a new Job with the same name. === pgo delete backup To delete a backup enter the following: .... pgo delete backup mycluster .... === pgo delete cluster You can remove a cluster by running: .... pgo delete cluster restoredb .... Note, that this command will not remove the PVC associated with this cluster. Selectors also apply to the delete command as follows: .... pgo delete cluster --selector=project=xray .... This command will cause any cluster matching the selector to be removed. You can remove a cluster and it's data files by running: .... pgo delete cluster restoredb --delete-data .... You can remove a cluster, it's data files, and all backups by running: .... pgo delete cluster restoredb --delete-data --delete-backups .... When you specify a destructive delete like above, you will be prompted to make sure this is what you want to do. If you don't want to be prompted you can enter the *--no-prompt* command line flag. === pgo scale When you create a Cluster, you will see in the output a variety of Kubernetes objects were created including: * a Deployment holding the primary PostgreSQL database * a Deployment holding the replica PostgreSQL database * a service for the primary database * a service for the replica databases Since Postgres is a single-primary database by design, the primary Deployment is set to a replica count of 1, it can not scale beyond 1. With Postgres, you can any n-number of replicas each of which connect to the primary forming a streaming replication postgres cluster. The Postgres replicas are read-only, whereas the primary is read-write. To create a Postgres replica enter a command such as: .... pgo scale mycluster .... The *pgo scale* command is additive, in that each time you execute it, it will create another replica which is added to the Postgres cluster. There are 2 service connections available to the PostgreSQL cluster. One is to the primary database which allows read-write SQL processing, and the other is to the set of read-only replica databases. The replica service performs round-robin load balancing to the replica databases. You can connect to the primary database and verify that it is replicating to the replica databases as follows: .... psql -h 10.107.180.159 -U postgres postgres -c 'table pg_stat_replication' .... You can view *all* clusters using the special keyword *all*: .... pgo show cluster all .... You can filter the results by Postgres version: .... pgo show cluster all --version=9.6.2 .... The scale command will let you specify a *--node-label* flag which can be used to influence what Kube node the replica will be scheduled upon. .... pgo scale mycluster --node-label=speed=fast .... If you don't specify a *--node-label* flag, a node affinity rule of *NotIn* will be specified to *prefer* that the replica be schedule on a node that the primary is not running on. You can also dictate what container resource and storage configurations will be used for a replica by passing in extra command flags: .... pgo scale mycluster --storage-config=storage1 --resources-config=small .... === pgo upgrade You can perform a minor Postgres version upgrade of either a database or cluster as follows: .... pgo upgrade mycluster .... When you run this command, it will cause the operator to delete the existing containers of the database or cluster and recreate them using the currently defined Postgres container image specified in your pgo configuration file. The database data files remain untouched, only the container is updated, this will upgrade your Postgres server version only. You can perform a major Postgres version upgrade of either a database or cluster as follows: .... pgo upgrade mycluster --upgrade-type=major .... When you run this command, it will cause the operator to delete the existing containers of the database or cluster and recreate them using the currently defined Postgres container image specified in your pgo configuration file. The database data files are converted to the new major Postgres version as specified by the current Postgres image version in your pgo configuration file. In this scenario, the upgrade is performed by the Postgres pg_upgrade utility which is containerized in the *crunchydata/crunchy-upgrade* container. The operator will create a Job which runs the upgrade container, using the existing Postgres database files as input, and output the updated database files to a new PVC. Once the upgrade job is completed, the operator will create the original database or cluster container mounted with the new PVC which contains the upgraded database files. As the upgrade is processed, the status of the *pgupgrade* CRD is updated to give the user some insight into how the upgrade is proceeding. Upgrades like this can take a long time if your database is large. The operator creates a watch on the upgrade job to know when and how to proceed. Likewise, you can upgrade the cluster using a command line flag: .... pgo upgrade mycluster --ccp-image-tag=centos7-9.6.9-1.8.3 pgo upgrade mycluster --upgrade-type=major --ccp-image-tag=centos7-9.6.9-1.8.3 .... === pgo delete upgrade To remove an upgrade CRD, issue the following: .... pgo delete upgrade .... === pgo show pvc You can view the files on a PVC as follows: .... pgo show pvc mycluster .... In this example, the PVC is *mycluster*. This command is useful in some cases to examine what files are on a given PVC. In the case where you want to list a specific path on a PVC you can specify the path option as follows: .... pgo show pvc mycluster --pvc-root=mycluster-backups .... You can also list all PVCs that are created by the operator using: .... pgo show pvc all .... === pgo show cluster You can view the passwords used by the cluster as follows: .... pgo show cluster mycluster --show-secrets=true .... Passwords are generated if not specified in your *pgo* configuration. === pgo test You can test the database connections to a cluster: .... pgo test mycluster .... This command will test each service defined for the cluster using the postgres, primary, and normal user accounts defined for the cluster. The cluster credentials are accessed and used to test the database connections. The equivalent *psql* command is printed out as connections are tried, along with the connection status. Like other commands, you can use the selector to test a series of clusters: .... pgo test --selector=env=research pgo test all .... You can get output using the *--output* flag: .... pgo test all -o json .... === pgo create policy To create a policy use the following syntax: .... pgo create policy policy1 --in-file=/tmp/policy1.sql pgo create policy policy1 --url=https://someurl/policy1.sql .... When you execute this command, it will create a policy named *policy1* using the input file */tmp/policy1.sql* as input. It will create on the server a PgPolicy CRD with the name *policy1* that you can examine as follows: .... kubectl get pgpolicies policy1 -o json .... Policies get automatically applied to any cluster you create if you define in your *pgo.yaml* configuration a CLUSTER.POLICIES value. Policy SQL is executed as the *postgres* user. To view policies: .... pgo show policy all .... === pgo delete policy To delete a policy use the following form: .... pgo delete policy policy1 .... === pgo apply To apply an existing policy to a set of clusters, issue a command like this: .... pgo apply policy1 --selector=name=mycluster .... When you execute this command, it will look up clusters that have a label value of *name=mycluster* and then it will apply the *policy1* label to that cluster and execute the policy SQL against that cluster using the *postgres* user account. Policies are executed as the superuser or *postgres* user in PostgreSQL. These should therefore be exercised with caution.  If you want to view the clusters than have a specific policy applied to them, you can use the *--selector* flag as follows to filter on a policy name (e.g. policy1): .... pgo show cluster --selector=policy1=pgpolicy .... === pgo user To create a new Postgres user to the *mycluster* cluster, execute: .... pgo createa user sally --selector=name=mycluster .... To delete a Postgres user in the *mycluster* cluster, execute: .... pgo user --delete-user=sally --selector=name=mycluster .... To delete that user in all clusters: .... pgo user --delete-user=sally .... To change the password for a user in the *mycluster* cluster: .... pgo user --change-password=sally --selector=name=mycluster .... The password is generated and applied to the user sally. To see user passwords that have expired past a certain number of days in the *mycluster* cluster: .... pgo user --expired=7 --selector=name=mycluster .... To assign users to a cluster: .... pgo create user user1 --valid-days=30 --managed --db=userdb --selector=name=xraydb1 .... In this example, a user named *user1* is created with a *valid until* password date set to expire in 30 days. That user will be granted access to the *userdb* database. This user account also will have an associated *secret* created to hold the password that was generated for this user. Any clusters that match the selector value will have this user created on it. To change a user password: .... pgo user --change-password=user1 --valid-days=10 --selector=name=xray1 .... In this example, a user named *user1* has its password changed to a generated value and the *valid until* expiration date set to 10 days from now, this command will take effect across all clusters that match the selector. If you specify *valid-days=-1* it will mean the password will not expire (e.g. infinity). To drop a user: .... pgo user --delete-user=user3 --selector=project=xray .... To see which passwords are set to expire in a given number of days: .... pgo user --expired=10 --selector=project=xray .... In this example, any clusters that match the selector are queried to see if any users are set to expire in 10 days. To update expired passwords in a cluster: .... pgo user --update-passwords --selector=name=mycluster .... === pgo label You can apply a user defined label to a cluster as follows: .... pgo label --label=env=research --selector=project=xray .... In this example, we apply a label of *env=research* to any clusters that have an existing label of *project=xray* applied. === pgo load A CSV file loading capability is supported currently. You can test that by creating a SQL Policy which will create a database table that will be loaded with the CSV data. For example: .... pgo create policy xrayapp --in-file=$COROOT/examples/policy/xrayapp.sql .... Then you can load a sample CSV file into a database as follows: .... pgo load --load-config=$COROOT/examples/sample-load-config.json --selector=name=mycluster .... The loading is based on a load definition found in the *sample-load-config.json* file. In that file, the data to be loaded is specified. When the *pgo load* command is executed, Jobs will be created to perform the loading for each cluster that matches the selector filter. If you include the *--policies* flag, any specified policies will be applied prior to the data being loaded. For example: .... pgo load --policies=\"rlspolicy,xrayapp\" --load-config=$COROOT/examples/sample-load-config.json --selector=name=mycluster .... Likewise you can load a sample json file into a database as follows: .... pgo load --policies=jsonload --load-config=$COROOT/examples/sample-json-load-config.json --selector=name=mycluster .... The load configuration file has the following YAML attributes: .Load Configuration File Definitions [width=\"90%\",cols=\"m,2\",frame=\"topbot\",options=\"header\"] |====================== |Attribute | Description |COImagePrefix| the pgo-load image prefix to use for the load job |COImageTag| the pgo-load image tag to use for the load job |DbDatabase| the database schema to use for loading the data |DbUser| the database user to use for loading the data |DbPort| the database port of the database to load |TableToLoad| the PostgreSQL table to load |FilePath| the name of the file to be loaded |FileType| either csv or json, determines the type of data to be loaded |PVCName| the name of the PVC that holds the data file to be loaded |SecurityContext| either fsGroup or SupplementalGroup values |====================== === pgo failover Starting with Release 2.6, there is a manual failover command which can be used to promote a replica to a primary role in a PostgreSQL cluster. This process includes the following actions: * pick a target replica to become the new primary * delete the current primary deployment to avoid user requests from going to multiple primary databases (split brain) * promote the targeted replica using *pg_ctl promote*, this will cause PostgreSQL to go into read-write mode * re-label the targeted replica to use the primary labels, this will match the primary service selector and cause new requests to the primary to be routed to the new primary (targeted replica) The command works like this: .... pgo failover mycluster --query .... That command will show you a list of replica targets you can choose to failover to. You will select one of those for the following command: .... pgo failover mycluster --target=mycluster-abxq .... There is a CRD called *pgtask* that will hold the failover request and also the status of that request. You can view the status by viewing it: .... kubectl get pgtasks mycluster-failover -o yaml .... Once completed, you will see a new replica has been started to replace the promoted replica, this happens automatically due to the re-lable, the Deployment will recreate its pod because of this. The failover typically takes only a few seconds, however, the creation of the replacement replica can take longer depending on how much data is being replicated. === pgo df You can use the *pgo df* command to see the disk capacity of a cluster's PVC versus that of the PostgreSQL data that has been written to disk. If the capacity is less than 50% then the output is printed in red to alert the user. Run the command as follows: .... pgo df mycluster pgo df --selector=name=mycluster pgo df --selector=name=hang CLUSTER STATUS PGSIZE CAPACITY PCTUSED mycluster up 30 MB 1Gi 2 .... === pgo status You can use the *pgo status* command to see overall pgo status. Selective metrics are displayed to provide some insights to the pgo user and administrator as to what is running currently in this namespace related to pgo. Run the command as follows: .... pgo status Operator Start: 2018-05-02 15:59:41 +0000 UTC Databases: 2 Backups: 2 Claims: 18 Total Volume Size: 18Gi Database Images: 4\tcrunchydata/crunchy-postgres:centos7-10.4-1.8.3 Databases Not Ready: .... "
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/",
	"title": "Crunchy Data PostgreSQL Operator",
	"tags": [],
	"description": "",
	"content": "image::crunchy_logo.png[Crunchy Data Logo,width=\"25%\",height=\"25%\", align=\"center\"]\n= PostgreSQL Operator\n\nv2.6, {docdate}\n\n== Documentation\n\nPlease view the official Crunchy Data PostgreSQL Operator documentation link:https://crunchydata.github.io/postgres-operator/[here]. If you are\ninterested in contributing or making an update to the documentation, please view the link:https://crunchydata.github.io/postgres-operator/contributing/[Contributing Guidelines].\n\n== What is the Operator?\n\nThe *postgres-operator* is a controller that runs within a Kubernetes cluster that provides a means to deploy and manage PostgreSQL clusters.\n\nUse the postgres-operator to -\n\n * deploy PostgreSQL containers including streaming replication clusters\n * scale up PostgreSQL clusters with extra replicas\n * add pgpool and metrics sidecars to PostgreSQL clusters\n * apply SQL policies to PostgreSQL clusters\n * assign metadata tags to PostgreSQL clusters\n * maintain PostgreSQL users and passwords\n * perform minor and major upgrades to PostgreSQL clusters\n * load simple CSV and JSON files into PostgreSQL clusters\n * perform database backups\n\n== Design\n\nThe *postgres-operator* design incorporates the following concepts -\n\n * adds Custom Resource Definitions for PostgreSQL to Kubernetes\n * adds controller logic that watches events on PostgreSQL resources\n * provides a command line client (*pgo*) and REST API for interfacing with the postgres-operator\n * provides for very customized deployments including container resources, storage configurations, and PostgreSQL custom configurations\n\nMore design information is found on the link:https://crunchydata.github.io/postgres-operator/how-it-works/[How It Works] page.\n\n== Requirements\n\nThe postgres-operator runs on any Kubernetes and Openshift platform that supports\nCustom Resource Definitions.\n\nThe Operator project builds and operates with the following containers -\n\n* link:https://hub.docker.com/r/crunchydata/pgo-lspvc/[PVC Listing Container]\n* link:https://hub.docker.com/r/crunchydata/pgo-rmdata/[Remove Data Container]\n* link:https://hub.docker.com/r/crunchydata/postgres-operator/[postgres-operator Container]\n* link:https://hub.docker.com/r/crunchydata/pgo-apiserver/[apiserver Container]\n* link:https://hub.docker.com/r/crunchydata/pgo-load/[file load Container]\n\nThis Operator is developed and tested on the following operating systems but is known to run on other operating systems -\n\n* *CentOS 7*\n* *RHEL 7*\n\n== Installation\n\nTo build and deploy the Operator on your Kubernetes system, follow the instructions documented on the link:https://crunchydata.github.io/postgres-operator/installation/[Installation] page.\n\nIf you're seeking to upgrade your existing Operator installation, please visit the link:https://crunchydata.github.io/postgres-operator/installation/upgrading-the-operator/[Upgrading the Operator] page.\n\n== Configuration\n\nThe operator is template-driven; this makes it simple to configure both the client and the operator. The configuration options are documented on the link:https://crunchydata.github.io/postgres-operator/installation/configuration/[Configuration] page.\n\n== Getting Started\n\n*postgres-operator* commands are documented on the link:https://crunchydata.github.io/postgres-operator/getting-started/[Getting Started] page.\n"
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://crunchydata.github.io/postgres-operator/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]