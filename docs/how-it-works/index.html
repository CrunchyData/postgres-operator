<!DOCTYPE html>
<html>
  <head>
    <title>Crunchy Data PostgreSQL Operator Documentation</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="generator" content="Hugo 0.40" />

<title>How it Works :: Crunchy Data PostgreSQL Operator Documentation</title>
<link rel="shortcut icon" href="https://crunchydata.github.io/postgres-operator/favicon.ico" type="image/x-icon" />
<link href="https://crunchydata.github.io/postgres-operator/css/nucleus.css" rel="stylesheet">
<link href="https://crunchydata.github.io/postgres-operator/css/font-awesome.min.css" rel="stylesheet">
<link href="https://crunchydata.github.io/postgres-operator/css/hybrid.css" rel="stylesheet">
<link href="https://crunchydata.github.io/postgres-operator/css/featherlight.min.css" rel="stylesheet">
<link href="https://crunchydata.github.io/postgres-operator/css/auto-complete.css" rel="stylesheet">
<link href="https://crunchydata.github.io/postgres-operator/theme-original/style.css" rel="stylesheet">

<link rel="stylesheet" href="https://crunchydata.github.io/postgres-operator/css/bootstrap.min.css">
<script src="https://crunchydata.github.io/postgres-operator/js/jquery-2.x.min.js"></script>
<style type="text/css">
  :root #header + #content > #left > #rlblock_left {
    display:none !important;
  }
</style>
<meta name="description" content="">


    
  </head>
  <body data-url="/how-it-works/">
    
      <div id="headermain"></div>
<nav id="sidebar" class="">



<div class="highlightable">
  <div id="header-wrapper">
    <div id="header">
      
	
  
    <a class="baselink" href="https://crunchydata.github.io/postgres-operator/">Crunchy Data PostgreSQL Operator Documentation</a>
  

    </div>
        <div class="searchbox">
		    <label for="search-by"><i class="fa fa-search"></i></label>
		    <input data-search-input id="search-by" type="text" placeholder="Search...">
		    <span data-search-clear=""><i class="fa fa-close"></i></span>
		</div>
		<script type="text/javascript" src="https://crunchydata.github.io/postgres-operator/js/lunr.min.js"></script>
		<script type="text/javascript" src="https://crunchydata.github.io/postgres-operator/js/auto-complete.js"></script>
		<script type="text/javascript">
        
            var baseurl = "https:\/\/crunchydata.github.io\/postgres-operator\/";
        
		</script>
		<script type="text/javascript" src="https://crunchydata.github.io/postgres-operator/js/search.js"></script>
  </div>

      <ul class="topics">
            <li data-nav-id="/" class="dd-item">
            <a href="https://crunchydata.github.io/postgres-operator/"><i class="fa fa-fw fa-home"></i></a>
            </li>
    <li data-nav-id="/installation/" class="dd-item haschildren
        ">
      <div>
      <a href="https://crunchydata.github.io/postgres-operator/installation/">Installation</a><i class="fa fa-angle-right fa-lg category-icon"></i>

      </div>
        <ul>
      <li data-nav-id="/installation/quick-installation/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/quick-installation/">
            Quick Installation
          </a>
        </div>
    </li>
      <li data-nav-id="/installation/manual-installation/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/manual-installation/">
            Manual Installation
          </a>
        </div>
    </li>
      <li data-nav-id="/installation/helm-chart/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/helm-chart/">
            Helm Chart
          </a>
        </div>
    </li>
      <li data-nav-id="/installation/configuration/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/configuration/">
            Configuration
          </a>
        </div>
    </li>
      <li data-nav-id="/installation/deployment/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/deployment/">
            Deployment
          </a>
        </div>
    </li>
      <li data-nav-id="/installation/upgrading-the-operator/" class="dd-item">
        <div>
          <a href="https://crunchydata.github.io/postgres-operator/installation/upgrading-the-operator/">
            Upgrading the Operator
          </a>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/getting-started/" class="dd-item
        ">
      <div>
      <a href="https://crunchydata.github.io/postgres-operator/getting-started/">Getting Started</a>

      </div>
    </li>
    <li data-nav-id="/how-it-works/" class="dd-item parent active
        ">
      <div>
      <a href="https://crunchydata.github.io/postgres-operator/how-it-works/">How it Works</a>

      </div>
    </li>
    <li data-nav-id="/contributing/" class="dd-item
        ">
      <div>
      <a href="https://crunchydata.github.io/postgres-operator/contributing/">Contributing</a>

      </div>
    </li>



        <section id="shortcuts">
                <li class="" role=""><h3>More</h3><a href="https://github.com/CrunchyData/postgres-operator" target="_blank" rel="noopener"><i class='fa fa-github'></i> <label>Github repo</label></a></li>
                <li class="" role=""><a href="https://github.com/CrunchyData/postgres-operator/releases/download/2.6/postgres-operator.2.6.tar.gz" target="_blank" rel="noopener"><i class='fa fa-cloud-download'></i> <label>Download</label></a></li>
                <li class="" role=""><a href="https://kubernetes.io/docs/" target="_blank" rel="noopener"><i class='fa fa-bookmark'></i> <label>Kubernetes Documentation</label></a></li>
                <li class="" role=""><a href="https://github.com/CrunchyData/postgres-operator/blob/master/LICENSE.md" target="_blank" rel="noopener"><i class='fa fa-file'></i> <label>License</label></a></li>
        </section>

    <hr />
    <li></li>

    </ul>

 <section id="footer">
    </section>
  </div>
</nav>



<section id="body">
<div id="overlay"></div>
<div class="padding highlightable">

  <div id="top-bar">
    
      
      
      
    <div id="top-github-link">
      <a class="github-link" href="https://crunchydata.github.io/postgres-operator/contributing/" target="blank">
        <i class="fa fa-info-circle"></i>
        How to contribute
      </a>
      <a class="github-link" href="https://github.com/CrunchyData/postgres-operator/edit/master/hugo/content/how-it-works/_index.adoc" target="blank">
        <i class="fa fa-code-fork"></i>
        Improve this page
      </a>
    </div><div id="breadcrumbs" itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb">
        <span id="sidebar-toggle-span">
          <a href="#" id="sidebar-toggle" data-sidebar-toggle="">
            <i class="fa fa-bars"></i>
          </a>
        </span>
        <span id="toc-menu"><i class="fa fa-list-alt"></i></span>
        <span class="links">
        




 <a href='https://crunchydata.github.io/postgres-operator/'>Crunchy Data PostgreSQL Operator</a> > How it Works




        </span>
    </div>

    
    <div class="progress">
        <div class="wrapper">
    
        </div>
    </div>
    

  </div>


<div id="body-inner">
  
    <h1>How it Works</h1>
  



    
    
    

<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_reference_architecture">Reference Architecture</a></li>
<li><a href="#_custom_resource_definitions">Custom Resource Definitions</a></li>
<li><a href="#_command_line_interface">Command Line Interface</a></li>
<li><a href="#_operator_deployment">Operator Deployment</a></li>
<li><a href="#_cli_design">CLI Design</a>
<ul class="sectlevel2">
<li><a href="#_verbs">Verbs</a></li>
</ul>
</li>
<li><a href="#_affinity">Affinity</a></li>
<li><a href="#_debugging">Debugging</a></li>
<li><a href="#_persistent_volumes">Persistent Volumes</a></li>
<li><a href="#_postgresql_operator_deployment_strategies">PostgreSQL Operator Deployment Strategies</a>
<ul class="sectlevel2">
<li><a href="#_strategies">Strategies</a></li>
<li><a href="#_specifying_a_strategy">Specifying a Strategy</a></li>
<li><a href="#_strategy_template_files">Strategy Template Files</a></li>
<li><a href="#_default_cluster_deployment_strategy_1">Default Cluster Deployment Strategy (1)</a></li>
<li><a href="#_cluster_deletion">Cluster Deletion</a></li>
<li><a href="#_custom_postgres_configurations">Custom Postgres Configurations</a></li>
<li><a href="#_metrics_collection">Metrics Collection</a></li>
<li><a href="#_manual_failover">Manual Failover</a></li>
<li><a href="#_auto_failover">Auto Failover</a></li>
</ul>
</li>
</ul>
</div>
<div class="paragraph">
<p>Latest Release: 3.2.0 2018-08-22</p>
</div>
<div class="sect1">
<h2 id="_reference_architecture">Reference Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So, what does the Postgres Operator actually deploy
when you create a cluster?</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://crunchydata.github.io/postgres-operator/OperatorReferenceDiagram.png" alt="Operator Reference Diagram">
</div>
</div>
<div class="paragraph">
<p>On this diagram, objects with dashed lines are components
that are optionally deployed as part of a PostgreSQL Cluster
by the operator. Objects with solid lines are the fundamental and
required components.</p>
</div>
<div class="paragraph">
<p>For example, within the Primary Deployment, the <strong>metrics</strong> container
is completely optional. That component can be deployed using
either the operator configuration or command line arguments if you
want to cause metrics to be collected from the Postgres container.</p>
</div>
<div class="paragraph">
<p>Replica deployments are similar to the primary deployment but
are optional. A replica is not required to be created unless the
capability for one is necessary. As you scale up the Postgres
cluster, the standard set of components gets deployed and
replication to the primary is started.</p>
</div>
<div class="paragraph">
<p>Notice that each cluster deployment gets its own unique
Persistent Volumes. Each volume can use different storage
configurations which is quite powerful.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_custom_resource_definitions">Custom Resource Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Kubernetes Custom Resource Definitions are used in the design
of the PostgreSQL Operator to define the following -</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster - <strong>pgclusters</strong></p>
</li>
<li>
<p>Backup - <strong>pgbackups</strong></p>
</li>
<li>
<p>Upgrade - <strong>pgupgrades</strong></p>
</li>
<li>
<p>Policy - <strong>pgpolicies</strong></p>
</li>
<li>
<p>Tasks - <strong>pgtasks</strong></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_command_line_interface">Command Line Interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The pgo command line interface (CLI) is used by a normal end-user
to create databases or clusters, or make changes to existing databases.</p>
</div>
<div class="paragraph">
<p>The CLI interacts with the <strong>apiserver</strong> REST API deployed
within the <strong>postgres-operator</strong> deployment.</p>
</div>
<div class="paragraph">
<p>From the CLI, users can view existing clusters that
were deployed using the CLI and Operator. Objects that were
not previously created by the Crunchy Operator are now viewable from
the CLI.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operator_deployment">Operator Deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The PostgreSQL Operator runs within a Deployment in the Kubernetes
cluster.  An administrator will deploy the operator deployment
using the provided script. Once installed and running, the Operator
pod will start watching for certain defined events.</p>
</div>
<div class="paragraph">
<p>The operator watches for create/update/delete actions on
the <strong>pgcluster</strong> custom resource definitions.  When
the CLI creates for example a new <strong>pgcluster</strong> custom resource
definition, the operator catches that event and creates pods and services
for that new cluster request.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cli_design">CLI Design</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The CLI uses the cobra package to implement CLI functionality
like help text, config file processing, and command line parsing.</p>
</div>
<div class="paragraph">
<p>The <strong>pgo</strong> client is essentially a REST client which communicates
to the <strong>pgo-apiserver</strong> REST server running within the Operator pod.  In
some cases you might want to split the apiserver out into its own
Deployment but the default deployment has a consolidated pod
that contains both the apiserver and operator containers simply for
convenience of deployment and updates.</p>
</div>
<div class="sect2">
<h3 id="_verbs">Verbs</h3>
<div class="paragraph">
<p>A user works with the CLI by entering verbs to indicate
what they want to do, as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">pgo show cluster all
pgo delete cluster db1 db2 db3
pgo create cluster mycluster</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, the <strong>show</strong>, <strong>backup</strong>, <strong>delete</strong>, and <strong>create</strong> verbs are used. The CLI is case sensitive and supports only lowercase.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_affinity">Affinity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can have the Operator add an affinity section to
a new Cluster Deployment if you want to cause Kubernetes to
attempt to schedule a primary cluster to a specific Kubernetes node.</p>
</div>
<div class="paragraph">
<p>You can see the nodes on your Kube cluster by running the following -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl get nodes</pre>
</div>
</div>
<div class="paragraph">
<p>You can then specify one of those names (e.g. kubeadm-node2)  when creating a cluster -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pgo create cluster thatcluster --node-name=kubeadm-node2</pre>
</div>
</div>
<div class="paragraph">
<p>The affinity rule inserted in the Deployment will used a <strong>preferred</strong>
strategy so that if the node were down or not available, Kube would
go ahead and schedule the Pod on another node.</p>
</div>
<div class="paragraph">
<p>You can always view the actual node your cluster pod is scheduled
on through the following command.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl get pod -o wide</pre>
</div>
</div>
<div class="paragraph">
<p>When you scale up a Cluster and add a replica, the scaling will
take into account the use of <code>--node-name</code>.  If it sees that a
cluster was created with a specific node name, then the replica
Deployment will add an affinity rule to attempt to schedule
the replica on a different node than the node the primary is
schedule on. This provides a simple version of high availability and
causes the primary and replicas to not live on the same Kubernetes
node.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_debugging">Debugging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To see if the operator pod is running enter the following -</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">kubectl get pod -l 'name=postgres-operator'</code></pre>
</div>
</div>
<div class="paragraph">
<p>To verify the operator is running and has deployed the Custom Resources execute the following -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubectl get crd</pre>
</div>
</div>
<div class="paragraph">
<p>The full list of CRDs that are created over time are shown below.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>NAME                               KIND
pgbackups.cr.client-go.k8s.io      CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgclusters.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgpolicies.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgpolicylogs.cr.client-go.k8s.io   CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgupgrades.cr.client-go.k8s.io     CustomResourceDefinition.v1beta1.apiextensions.k8s.io
pgtasks.cr.client-go.k8s.io        CustomResourceDefinition.v1beta1.apiextensions.k8s.io</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_persistent_volumes">Persistent Volumes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Currently, the operator does not delete persistent volumes by default. Instead,
it deletes the claims on the volumes. Starting with release 2.4, the Operator
will create Jobs that actually run <strong>rm</strong> commands on the data volumes before
actually removing the Persistent Volumes if the user passes a `--delete-data `
flag when deleting a database cluster.</p>
</div>
<div class="paragraph">
<p>Likewise, if the user passes <code>--delete-backups</code> during cluster deletion
a Job is created to remove all the backups for a cluster include
the related Persistent Volume.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_postgresql_operator_deployment_strategies">PostgreSQL Operator Deployment Strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes the various deployment strategies
offered by the operator.  A deployment in this case is
the set of objects created in Kubernetes when a
custom resource definition of type <strong>pgcluster</strong> is created.
CRDs are created by the pgo client command and acted upon
by the postgres operator.</p>
</div>
<div class="sect2">
<h3 id="_strategies">Strategies</h3>
<div class="paragraph">
<p>To support different types of deployments, the operator supports
multiple strategy implementations.  Currently there is
only a default <strong>cluster</strong> strategy.</p>
</div>
<div class="paragraph">
<p>In the future, more deployment strategies will be supported
to offer users more customization to what they see deployed
in their Kubernetes cluster.</p>
</div>
<div class="paragraph">
<p>Being open source, users can also write their own strategy!</p>
</div>
</div>
<div class="sect2">
<h3 id="_specifying_a_strategy">Specifying a Strategy</h3>
<div class="paragraph">
<p>In the pgo client configuration file, there is a
`CLUSTER.STRATEGY `setting.  The current value of the
default strategy is <strong>1</strong>.  If you don&#8217;t set that value, the
default strategy is assumed.  If you set that value to something
not supported, the operator will log an error.</p>
</div>
</div>
<div class="sect2">
<h3 id="_strategy_template_files">Strategy Template Files</h3>
<div class="paragraph">
<p>Each strategy supplies its set of templates used by the operator
to create new pods, services, etc.</p>
</div>
<div class="paragraph">
<p>When the operator is deployed, part of the deployment process
is to copy the required strategy templates into a ConfigMap (<strong>operator-conf</strong>)
that gets mounted into <code>/operator-conf</code> within the operator pod.</p>
</div>
<div class="paragraph">
<p>The directory structure of the strategy templates is as
follows -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>|-- backup-job.json
|-- cluster
|   |-- 1
|       |-- cluster-deployment-1.json
|       |-- cluster-replica-deployment-1.json
|       |-- cluster-service-1.json
|
|-- pvc.json</pre>
</div>
</div>
<div class="paragraph">
<p>In this structure, each strategy&#8217;s templates live in a subdirectory
that matches the strategy identifier.  The default strategy templates
are denoted by the value of <strong>1</strong> in the directory structure above.</p>
</div>
<div class="paragraph">
<p>If you add another strategy, the file names <strong>must</strong> be unique within
the entire strategy directory.  This is due to the way the templates
are stored within the ConfigMap.</p>
</div>
</div>
<div class="sect2">
<h3 id="_default_cluster_deployment_strategy_1">Default Cluster Deployment Strategy (1)</h3>
<div class="paragraph">
<p>Using the default cluster strategy, a <strong>cluster</strong> when created by the operator will create the
following on a Kubernetes cluster -</p>
</div>
<div class="ulist">
<ul>
<li>
<p>deployment running a Postgres <strong>primary</strong> container with replica count of 1</p>
</li>
<li>
<p>service mapped to the <strong>primary</strong> Postgres database</p>
</li>
<li>
<p>service mapped to the <strong>replica</strong> Postgres database</p>
</li>
<li>
<p>PVC for the <strong>primary</strong> will be created if not specified in configuration, this
assumes you are using a non-shared volume technology (e.g. Amazon EBS),
if the <code>CLUSTER.PVC_NAME</code> value is set in your configuration then a
shared volume technology is assumed (e.g. HostPath or NFS), if a PVC
is created for the primary, the naming convention is <strong>clustername</strong>
where clustername is the name of your cluster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you want to add a Postgres replica to a cluster, you will
<strong>scale</strong> the cluster. For each <strong>replica-count</strong>, a Deployment
will be created that acts as a PostgreSQL replica.</p>
</div>
<div class="paragraph">
<p>This is very different than using a StatefulSet to scale
up PostgreSQL.  Why would you do it this way? Imagine a case
where you want different parts of your PostgreSQL cluster to
use different storage configurations,. With this method, it can
be done through using specific placement and deployments of each
part of the cluster.</p>
</div>
<div class="paragraph">
<p>This same concept applies to node selection for the PostgreSQL
cluster components.  The Operator will let you define precisely
which node that the PostgreSQL component should be placed upon
using node affinity rules.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cluster_deletion">Cluster Deletion</h3>
<div class="paragraph">
<p>When you run the following, the cluster and its services will be
deleted.  However, the data files and backup files will remain as
well as the PVCs for this cluster.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>pgo delete cluster mycluster</pre>
</div>
</div>
<div class="paragraph">
<p>However, to remove the data files from the PVC you can pass the following flag -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>--delete-data</pre>
</div>
</div>
<div class="paragraph">
<p>This causes a workflow to be started to remove the
data files on the primary cluster deployment PVC.</p>
</div>
<div class="paragraph">
<p>The following flag will cause <strong>all</strong> of the backup files
to be removed.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>--delete-backups</pre>
</div>
</div>
<div class="paragraph">
<p>The data removal workflow includes the following steps -</p>
</div>
<div class="ulist">
<ul>
<li>
<p>create a pgtask CRD to hold the PVC name and cluster name to be removed</p>
</li>
<li>
<p>the CRD is watched, and on an ADD will cause a Job to be created that will run the <strong>rmdata</strong> container using the PVC name and cluster name as parameters which determine the PVC to mount, and the file path to remove under that PVC</p>
</li>
<li>
<p>the <strong>rmdata</strong> Job is watched by the Operator, and upon a successful status completion the actual PVC is removed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This workflow insures that a PVC is not removed until all the data files are removed.  Also, a Job was used for the removal of files since that can be a time consuming task.</p>
</div>
<div class="paragraph">
<p>The files are removed by the <strong>rmdata</strong> container which essentially
issues the following command to remove the files -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>rm -rf /pgdata/&lt;some path&gt;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_custom_postgres_configurations">Custom Postgres Configurations</h3>
<div class="paragraph">
<p>Starting in release 2.5, users and administrators can specify a
custom set of Postgres configuration files be used when creating
a new Postgres cluster.  The configuration files you can
change include -</p>
</div>
<div class="ulist">
<ul>
<li>
<p>postgresql.conf</p>
</li>
<li>
<p>pg_hba.conf</p>
</li>
<li>
<p>setup.sql</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Different configurations for PostgreSQL might be defined for
the following -</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OLTP types of databases</p>
</li>
<li>
<p>OLAP types of databases</p>
</li>
<li>
<p>High Memory</p>
</li>
<li>
<p>Minimal Configuration for Development</p>
</li>
<li>
<p>Project Specific configurations</p>
</li>
<li>
<p>Special Security Requirements</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_global_configmap">Global ConfigMap</h4>
<div class="paragraph">
<p>If you create a <strong>configMap</strong> called <strong>pgo-custom-pg-config</strong> with any
of the above files within it, new clusters will use those configuration
files when setting up a new database instance.  You do <strong>NOT</strong> have to
specify all of the configuration files. It is entirely up to your use case
to determine which to use.</p>
</div>
<div class="paragraph">
<p>An example set of configuration files and a script to create the
global configMap is found at -</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$COROOT/examples/custom-config</pre>
</div>
</div>
<div class="paragraph">
<p>If you run the <strong>create.sh</strong> script there, it will create the configMap
that will include the PostgreSQL configuration files within that directory.</p>
</div>
</div>
<div class="sect3">
<h4 id="_config_files_purpose">Config Files Purpose</h4>
<div class="paragraph">
<p>The <strong>postgresql.conf</strong> file is the main Postgresql configuration file that allows
the definition of a wide variety of tuning parameters and features.</p>
</div>
<div class="paragraph">
<p>The <strong>pg_hba.conf</strong> file is the way Postgresql secures client access.</p>
</div>
<div class="paragraph">
<p>The <strong>setup.sql</strong> file is a Crunchy Container Suite configuration
file used to initially populate the database after the initial <strong>initdb</strong>
is run when the database is first created. Changes would be made
to this if you wanted to define which database objects are created by
default.</p>
</div>
</div>
<div class="sect3">
<h4 id="_granular_config_maps">Granular Config Maps</h4>
<div class="paragraph">
<p>Granular config maps can be defined if it is necessary to use
a different set of configuration files for different clusters
rather than having a single configuration (e.g. Global Config Map).
A specific set of ConfigMaps with their own set of PostgreSQL
configuration files can be created. When creating new clusters, a
<code>--custom-config</code> flag can be passed along with the name of the
ConfigMap which will be used for that specific cluster or set of
clusters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_defaults">Defaults</h4>
<div class="paragraph">
<p>If there&#8217;s no reason to change the default PostgreSQL configuration
files that ship with the Crunchy Postgres container, there&#8217;s no
requirement to. In this event, continue using the Operator as usual
and avoid defining a global configMap.</p>
</div>
</div>
<div class="sect3">
<h4 id="_labeling">Labeling</h4>
<div class="paragraph">
<p>When a custom configMap is used in cluster creation, the Operator
labels the primary Postgres Deployment with a label of
<strong>custom-config</strong> and a value of what configMap was used when creating
the database.</p>
</div>
<div class="paragraph">
<p>Commands coming in future releases will take advantage of this
labeling.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metrics_collection">Metrics Collection</h3>
<div class="paragraph">
<p>If you add a <strong>--metrics</strong> flag to <strong>pgo create cluster</strong> it will
cause the <strong>crunchy-collect</strong> container to be added to your
Postgres cluster.</p>
</div>
<div class="paragraph">
<p>That container requires you run the <strong>crunchy-metrics</strong> containers
as defined within the <strong>crunchy-containers</strong> project.</p>
</div>
<div class="paragraph">
<p>See <a href="https://crunchydata.github.io/crunchy-containers/getting-started/kubernetes-and-openshift/#_metrics_and_performance">the crunchy-containers Metrics example</a> for more details on setting up the <strong>crunchy-metrics</strong> solution.</p>
</div>
</div>
<div class="sect2">
<h3 id="_manual_failover">Manual Failover</h3>
<div class="paragraph">
<p>With manual failover some key features include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when you perform a failover, a new replica is created to replace the
replica that was promoted to even out the cluster to the original
number of replicas</p>
</li>
<li>
<p>when you perform a failover, the promoted replica is removed from the pgreplica CRD to represent the current <strong>truth</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>pgo failover --query</code> command will return a list of replica
targets which you can select from.  That list include the <strong>Ready</strong> status
of the database as well as the Kube node name it is running on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_auto_failover">Auto Failover</h3>
<div class="paragraph">
<p>Starting with release 3.1, there is an <strong>auto</strong> failover mechanism
that can be leveraged by <strong>pgo</strong> users if enabled.</p>
</div>
<div class="paragraph">
<p>This feature will cause the operator to start a timer on a database
primary that has received a <strong>NotReady</strong> status after the database
has started.  This can happen if for instance the primary database
loses the connection to its database storage (e.g. gluster, NFS).</p>
</div>
<div class="paragraph">
<p>Once the timer is started, if the primary database does not get
back to a <strong>Ready</strong> status within that timer period, a failover
is triggered for this cluster.  The failover target is selected
by the auto failover logic.</p>
</div>
<div class="paragraph">
<p>The amount of time (in seconds) the auto failover timer will wait before
triggering a failover is determined by the following <strong>pgo.yaml</strong> setting:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>AutofailSleepSeconds:  9</pre>
</div>
</div>
<div class="paragraph">
<p>If the above setting is not configured a default value of 30 seconds is
chose.</p>
</div>
<div class="paragraph">
<p>The logic of auto failover works like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the readiness probe on the primary database container is executed every few seconds to check the <strong>readiness</strong> of the database, this is what tells Kubernetes whether or not the container is <strong>Ready</strong> or <strong>NotReady</strong>.</p>
</li>
<li>
<p>if a <strong>NotReady</strong> state is detected then that event is caught by the operator which is watching for database containers created by the operator</p>
</li>
<li>
<p>upon a <strong>NotReady</strong> event, a timer is started for that database which acts as the final check as to if a failover is required for that database</p>
</li>
<li>
<p>if the timer expires and the state is still <strong>Not Ready</strong> then the manual
failover logic is executed for this cluster which causes a promotion of
a replica to primary, and also creates a replacement replica</p>
</li>
<li>
<p>only replica targets with a status of <strong>Ready</strong> will be used to select
the target to promote</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The readiness probe settings are defined in the following template:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>conf/postgres-operator/cluster/1/cluster-deployment-1.json</pre>
</div>
</div>
<div class="paragraph">
<p>The readiness probe settings determine how often the database check
is performed.  See the Kubernetes documentation on readiness probes for
more details on these settings.</p>
</div>
</div>
</div>
</div>



    
    
          <footer class=" footline" >
	
</footer>
  </div>
</div>

<div id="navigation">
<a class="nav nav-prev" href="https://crunchydata.github.io/postgres-operator/getting-started/" title="Getting Started"> <i class="fa fa-chevron-left"></i><label>Getting Started</label></a>
    <a class="nav nav-next" href="https://crunchydata.github.io/postgres-operator/contributing/" title="Contributing" style="margin-right: 0px;"><label>Contributing</label><i class="fa fa-chevron-right"></i></a></div>

</section>
<div style="left: -1000px; overflow: scroll; position: absolute; top: -1000px; border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;">
  <div style="border: none; box-sizing: content-box; height: 200px; margin: 0px; padding: 0px; width: 200px;"></div>
</div>    

<script src="https://crunchydata.github.io/postgres-operator/js/clipboard.min.js"></script>
<script src="https://crunchydata.github.io/postgres-operator/js/featherlight.min.js"></script>
<script src="https://crunchydata.github.io/postgres-operator/js/html5shiv-printshiv.min.js"></script>

<script src="https://crunchydata.github.io/postgres-operator/js/modernizr.custom.71422.js"></script>
<script src="https://crunchydata.github.io/postgres-operator/js/docdock.js"></script>
<script src="https://crunchydata.github.io/postgres-operator/theme-original/script.js"></script>


    

    
    

    
  </body>
</html>